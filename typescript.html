<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TypeScript</title>
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">

  <style>
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #60a5fa;
      --muted: #94a3b8;
      --glass: rgba(255, 255, 255, 0.03)
    }

    body {
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
      background: linear-gradient(180deg, #071028 0%, #071a2b 100%);
      color: #e6eef8;
      margin: 0;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
    }

    header {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 18px;
    }

    header h1 {
      font-size: 20px;
      margin-bottom: 7px;
    }

    header p {
      margin: 0;
      color: var(--muted);
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 18px 0;
    }

    .controls input[type=text],
    .controls select,
    .controls button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: var(--glass);
      color: inherit;
      min-width: 220px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 12px;
    }

    .card {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      padding: 14px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.03);
      box-shadow: 0 6px 18px rgba(2, 6, 23, 0.6);
      transition: transform .14s ease, box-shadow .14s;
      cursor: pointer;
    }

    .card:hover {
      transform: translateY(-6px);
      box-shadow: 0 12px 30px rgba(2, 6, 23, 0.7);
    }

    .meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .num {
      font-weight: 700;
      background: rgba(255, 255, 255, 0.03);
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 13px;
      color: #7a7af0;
    }

    .cat {
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 999px;
      font-weight: 600;
    }

    .cat.basic {
      background: rgba(96, 165, 250, 0.12);
      color: #60a5fa;
    }

    .cat.intermediate {
      background: rgba(250, 204, 21, 0.08);
      color: #facc15;
    }

    .cat.advanced {
      background: rgba(240, 82, 69, 0.06);
      color: #f87171;
    }

    footer {
      margin-top: 18px;
      color: var(--muted);
      font-size: 13px;
    }

    .desc {
      color: #7a7af0;
    }
  </style>
</head>

<body>
  <nav class="navbar navbar-default" style="border-radius: 0px;">
    <div class="container-fluid">
      <div class="navbar-header active">
        <a class="navbar-brand" href="#" style="background-color: #dff3f5;">Build CV</a>
      </div>
      <ul class="nav navbar-nav">
        <li><a href="https://www.buildcv.co.in/" style="font-size: 16px;">Home</a></li>
      </ul>
      <div class="navbar-right" style="padding:10px 20px; font-size: 16px; font-weight: 600;">
        <a href="mailto:contact@buildcv.co.in" style="color:#333;">üìß buildcv.co.in@zohomail.in</a>
      </div>
    </div>
  </nav>

  <div class="container">
    <header>
      <div>
        <h1>TypeScript Topics</h1>
        <p>Use search or filter to find a topic.</p>
      </div>
    </header>

    <div class="controls">
      <input id="search" type="text" placeholder="Search topics..." />
      <select id="filter">
        <option value="all" style="background: #071028;">All categories</option>
        <option value="Basic" style="background: #071028;">Basic</option>
        <option value="Intermediate" style="background: #071028;">Intermediate</option>
        <option value="Advanced" style="background: #071028;">Advanced</option>
      </select>
      <button id="reset">Reset</button>
    </div>

    <div id="grid" class="grid"></div>

    <footer>Showing <span id="count">0</span> of 75 topics</footer>
  </div>

  <!-- Modal -->
  <div id="topicModal" class="modal fade" role="dialog">
    <div class="modal-dialog modal-lg">
      <div class="modal-content" style="color:#000;">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title" id="modalTitle"></h4>
        </div>
        <div class="modal-body" id="modalBody"></div>
      </div>
    </div>
  </div>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>

  <script>
    const topics = [
      { n: 1, title: 'Setup and Hello World', cat: 'Basic' },
      { n: 2, title: 'Primitive Types', cat: 'Basic' },
      { n: 3, title: 'Instance Types', cat: 'Basic' },
      { n: 4, title: 'Arrays And Tuples', cat: 'Basic' },
      { n: 5, title: 'Object Types and Type Aliases', cat: 'Basic' },
      { n: 6, title: 'const declarations', cat: 'Basic' },
      { n: 7, title: 'Functions', cat: 'Basic' },
      { n: 8, title: 'Structural Typing', cat: 'Basic' },
      { n: 9, title: 'Classes', cat: 'Basic' },
      { n: 10, title: 'Target Compiler Option', cat: 'Basic' },
      { n: 11, title: 'Generics', cat: 'Basic' },
      { n: 12, title: 'Special Types : any and unknown', cat: 'Basic' },
      { n: 13, title: 'JavaScript to TypeScript', cat: 'Basic' },
      { n: 14, title: 'Creating a Frontend Project', cat: 'Basic' },
      { n: 15, title: 'Type Assertions', cat: 'Basic' },
      { n: 16, title: 'Type Casting', cat: 'Basic' },
      { n: 17, title: 'Modules', cat: 'Basic' },
      { n: 18, title: 'Type Declarations', cat: 'Basic' },
      { n: 19, title: 'Creating an NPM Package', cat: 'Basic' },
      { n: 20, title: 'Async Await', cat: 'Basic' },
      { n: 21, title: 'ts-node', cat: 'Basic' },
      { n: 22, title: 'Lexical this', cat: 'Basic' },
      { n: 23, title: 'readonly modifier', cat: 'Basic' },
      { n: 24, title: 'Union Types', cat: 'Basic' },
      { n: 25, title: 'Literal Types', cat: 'Basic' },
      { n: 26, title: 'Type Narrowing', cat: 'Basic' },
      { n: 27, title: 'Discriminated Unions', cat: 'Basic' },
      { n: 28, title: 'Class Parameter Properties', cat: 'Basic' },
      { n: 29, title: 'Strict Compiler Option', cat: 'Basic' },
      { n: 30, title: 'Null versus Undefined', cat: 'Basic' },
      { n: 31, title: 'Intersection types', cat: 'Intermediate' },
      { n: 32, title: 'Optional modifier', cat: 'Intermediate' },
      { n: 33, title: 'Non-null Assertion Operator', cat: 'Intermediate' },
      { n: 34, title: 'Interfaces', cat: 'Intermediate' },
      { n: 35, title: 'Interface Declaration Merging', cat: 'Intermediate' },
      { n: 36, title: 'Types versus Interfaces', cat: 'Intermediate' },
      { n: 37, title: 'never type', cat: 'Intermediate' },
      { n: 38, title: 'implements keyword', cat: 'Intermediate' },
      { n: 39, title: 'Definite Assignment Assertion', cat: 'Intermediate' },
      { n: 40, title: 'User Defined Type Guards', cat: 'Intermediate' },
      { n: 41, title: 'Assertion Functions', cat: 'Intermediate' },
      { n: 42, title: 'Function Overloading', cat: 'Intermediate' },
      { n: 43, title: 'Call Signatures', cat: 'Intermediate' },
      { n: 44, title: 'Abstract Classes', cat: 'Intermediate' },
      { n: 45, title: 'Index Signatures', cat: 'Intermediate' },
      { n: 46, title: 'Readonly Arrays and Tuples', cat: 'Intermediate' },
      { n: 47, title: 'Double Assertion', cat: 'Intermediate' },
      { n: 48, title: 'const Assertion', cat: 'Intermediate' },
      { n: 49, title: 'this parameter', cat: 'Intermediate' },
      { n: 50, title: 'Generic Constraints', cat: 'Intermediate' },
      { n: 51, title: 'Dealing with Temporal Uncertainty', cat: 'Intermediate' },
      { n: 52, title: 'typeof type operator', cat: 'Intermediate' },
      { n: 53, title: 'Lookup Types', cat: 'Intermediate' },
      { n: 54, title: 'keyof type operator', cat: 'Intermediate' },
      { n: 55, title: 'Conditional Types', cat: 'Intermediate' },
      { n: 56, title: 'Conditional Types with Unions and never', cat: 'Intermediate' },
      { n: 57, title: 'infer keyword and ReturnType<T>', cat: 'Intermediate' },
      { n: 58, title: 'Mapped Types', cat: 'Intermediate' },
      { n: 59, title: 'Mapped type modifiers', cat: 'Intermediate' },
      { n: 60, title: 'Template Literal Type', cat: 'Intermediate' },
      { n: 61, title: 'Partial<T>', cat: 'Advanced' },
      { n: 62, title: 'Required<T>', cat: 'Advanced' },
      { n: 63, title: 'Readonly<T>', cat: 'Advanced' },
      { n: 64, title: 'Record<K,V>', cat: 'Advanced' },
      { n: 65, title: 'AutoComplete Literal Unions with Primitives', cat: 'Advanced' },
      { n: 66, title: 'Project References', cat: 'Advanced' },
      { n: 67, title: 'undefined vs optional', cat: 'Advanced' },
      { n: 68, title: 'satisfies operator', cat: 'Advanced' },
      { n: 69, title: 'PropertyKey', cat: 'Advanced' },
      { n: 70, title: 'ThisType<T> Utility', cat: 'Advanced' },
      { n: 71, title: 'Awaited<T> Utility', cat: 'Advanced' },
      { n: 72, title: 'String Manipulation Utilities', cat: 'Advanced' },
      { n: 73, title: 'Mapped Types as Clauses', cat: 'Advanced' },
      { n: 74, title: 'TypeScript Unions vs Intersection Mental Model', cat: 'Advanced' },
      { n: 75, title: 'TypeScript Enums are Bad', cat: 'Advanced' }
    ];
    //#region Topic Contents
    const topicContent = {
      1: `
      <h4>Introduction to TypeScript</h4>
    <p>TypeScript is a strongly typed programming language that builds on JavaScript. TypeScript is a superset of JavaScript, which means any valid JavaScript code is also valid TypeScript code.</p>
    <p><b>TypeScript = JavaScript + Type System.</b> Where the Type System means (type safety, interfaces, generics, etc.)</p>  
    <h4>Setup and Hello World</h4>
    <p><strong>Step 1:</strong> Install TypeScript globally</p>
    <pre><code>npm install -g typescript</code></pre>
    <p><strong>Step 2:</strong> Create a file <code>hello.ts</code></p>
    <pre><code>let message: string = "Hello, TypeScript!";
console.log(message);</code></pre>
    <p><strong>Step 3:</strong> Compile and run</p>
    <pre><code>tsc hello.ts
node hello.js</code></pre>
    <p>This verifies your environment is set up correctly.</p>

    <hr/>
    <h4>Installing NodeJS and Creating Your First TypeScript Project</h4>
    <p>Now, in order to get started with TypeScript, the first thing that we need to do is to install the NodeJS runtime.</p>
    <p>NodeJS is a standard development tool used for developing both backend as well as front-end applications for JavaScript as well as TypeScript.</p>
    <p>To install NodeJS, open up your browser and head to <a href="https://nodejs.org" target="_blank">nodejs.org</a>. The homepage will suggest a version for your OS, or you can go to the download page to select one manually.</p>

    <p>Once downloaded and installed, verify installation:</p>
    <pre><code>node --version</code></pre>
    <p>You can also verify the npm executables:</p>
    <pre><code>npm --version
npx --version</code></pre>

    <h5>Initialize a TypeScript Project</h5>
    <pre><code>mkdir my-ts-app
cd my-ts-app
npm init -y</code></pre>
    <p>This creates a Node.js package. Now install TypeScript:</p>
    <pre><code>npm install typescript</code></pre>
    <p>This installs the TypeScript compiler (<code>tsc</code>) locally in your project.</p>

    <p>Initialize a TypeScript config file:</p>
    <pre><code>npx tsc --init --rootDir src --outDir lib</code></pre>
    <p>This creates a <code>tsconfig.json</code> file which stores compiler options.</p>

    <h5>Recommended IDE</h5>
    <p>Use <strong>Visual Studio Code</strong> ‚Äî it‚Äôs developed by Microsoft (the creators of TypeScript). You can download it from <a href="https://code.visualstudio.com" target="_blank">code.visualstudio.com</a>.</p>

    <h5>Write Your First TypeScript Code</h5>
    <p>Create a file <code>src/index.ts</code> and add:</p>
    <pre><code>let message: string = "Hello World";
console.log(message);</code></pre>

    <h5>Compile and Run</h5>
    <pre><code>npx tsc --watch</code></pre>
    <p>This runs the TypeScript compiler in watch mode. It generates the compiled JavaScript inside <code>lib/index.js</code>.</p>

    <p>Run the compiled code:</p>
    <pre><code>node lib/index.js</code></pre>
    <p>You should see your message logged in the console.</p>

    <h5>Understanding Type Annotations</h5>
    <p>The main difference between TypeScript and JavaScript is type annotations. For example:</p>
    <pre><code>let message: string = "Hello";
message = 123; // ‚ùå Error: Type 'number' is not assignable to type 'string'</code></pre>
    <p>TypeScript catches these errors at compile time, helping prevent runtime issues.</p>

    <p>And with that said, congratulations on finishing the first lesson!</p>
  `,

      2: `
    <h4>Primitive Types in TypeScript</h4>
    <p>Primitive types are the most basic building blocks of data in TypeScript. They represent single immutable values and form the foundation of all data handling in TypeScript.</p>
    <p>TypeScript includes all JavaScript primitives and adds compile-time type checking for better safety and readability.</p>

    <hr/>
    <h5>1Ô∏è‚É£ string</h5>
    <p>Represents textual data. Strings can use single quotes, double quotes, or template literals.</p>
    <pre><code>let firstName: string = "Abhishek";
let greeting: string = \`Hello, \${firstName}!\`;</code></pre>
    <p><b>Tip:</b> Use template literals for string interpolation.</p>

    <hr/>
    <h5>2Ô∏è‚É£ number</h5>
    <p>Represents both integers and floating-point numbers. TypeScript does not differentiate between int and float.</p>
    <pre><code>let age: number = 25;
let price: number = 99.99;</code></pre>

    <hr/>
    <h5>3Ô∏è‚É£ boolean</h5>
    <p>Represents logical values: <code>true</code> or <code>false</code>.</p>
    <pre><code>let isLoggedIn: boolean = true;
let isCompleted: boolean = false;</code></pre>

    <hr/>
    <h5>4Ô∏è‚É£ null and undefined</h5>
    <p>Used to represent the absence of a value. When <code>strictNullChecks</code> is enabled, these types must be explicitly handled.</p>
    <pre><code>let nothing: null = null;
let notAssigned: undefined = undefined;</code></pre>
    <p><b>Note:</b> You cannot assign <code>null</code> or <code>undefined</code> to a variable of another type if <code>strictNullChecks</code> is true.</p>

    <hr/>
    <h5>5Ô∏è‚É£ symbol</h5>
    <p>Introduced in ES6, symbols are unique identifiers often used as object property keys.</p>
    <pre><code>let id1: symbol = Symbol("id");
let id2: symbol = Symbol("id");
console.log(id1 === id2); // false</code></pre>

    <hr/>
    <h5>6Ô∏è‚É£ bigint</h5>
    <p>Used to represent very large integers beyond JavaScript‚Äôs number limit.</p>
    <pre><code>let bigNumber: bigint = 1234567890123456789012345678901234567890n;</code></pre>

    <hr/>
    <h5>7Ô∏è‚É£ any</h5>
    <p>Disables type checking for a variable. It can hold any type of value, but should be used cautiously.</p>
    <pre><code>let randomValue: any = "Hello";
randomValue = 42; // ‚úÖ Allowed
randomValue = true; // ‚úÖ Allowed</code></pre>

    <hr/>
    <h5>8Ô∏è‚É£ unknown</h5>
    <p>Similar to <code>any</code>, but safer. You must perform a type check before using it.</p>
    <pre><code>let value: unknown = "Hello";

if (typeof value === "string") {
  console.log(value.toUpperCase()); // ‚úÖ Safe
}</code></pre>

    <hr/>
    <h5>üìã Summary Table</h5>
    <table border="1" cellpadding="6" cellspacing="0">
      <thead>
        <tr><th>Type</th><th>Example</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr><td><code>string</code></td><td>"Hello"</td><td>Text values</td></tr>
        <tr><td><code>number</code></td><td>42, 3.14</td><td>Numeric values</td></tr>
        <tr><td><code>boolean</code></td><td>true, false</td><td>Logical values</td></tr>
        <tr><td><code>null</code></td><td>null</td><td>Explicit absence of value</td></tr>
        <tr><td><code>undefined</code></td><td>undefined</td><td>Uninitialized variable</td></tr>
        <tr><td><code>symbol</code></td><td>Symbol("id")</td><td>Unique identifier</td></tr>
        <tr><td><code>bigint</code></td><td>123n</td><td>Large integer values</td></tr>
        <tr><td><code>any</code></td><td>Dynamic</td><td>Turns off type checking</td></tr>
        <tr><td><code>unknown</code></td><td>Dynamic but safe</td><td>Requires type check before use</td></tr>
      </tbody>
    </table>

    <p><b>Summary:</b> Primitive types ensure your variables hold predictable and valid values, reducing runtime errors and improving code quality.</p>
  `,

      3: `
    <h4>Instance Types in TypeScript</h4>
    <p>In TypeScript, <b>instance types</b> refer to the types of objects created from classes. They represent the <i>shape</i> of an instance of a class ‚Äî meaning all the public properties and methods available on the class instance.</p>
    <p>Understanding instance types helps you write code that correctly uses class instances and leverages TypeScript‚Äôs strong typing for object-oriented programming.</p>

    <hr/>
    <h5>1Ô∏è‚É£ Defining a Class</h5>
    <pre><code>class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(\`Hello, my name is \${this.name} and I am \${this.age} years old.\`);
  }
}

// Creating an instance
const p1 = new Person("Abhishek", 25);
p1.greet();</code></pre>

    <p>Here, <code>p1</code> is an <b>instance</b> of the <code>Person</code> class, and its type is the <b>instance type</b> of <code>Person</code>.</p>

    <hr/>
    <h5>2Ô∏è‚É£ Instance Type vs Class Type</h5>
    <p>Every class in TypeScript has two types associated with it:</p>
    <ul>
      <li><b>The instance type</b> ‚Äî describes the shape of objects created by the class.</li>
      <li><b>The constructor type</b> ‚Äî describes the class itself (i.e., the constructor function).</li>
    </ul>

    <pre><code>class Car {
  brand: string;
  constructor(brand: string) {
    this.brand = brand;
  }
}

// Instance type
let myCar: Car = new Car("Tesla");

// Constructor type
let carConstructor: typeof Car = Car;

const anotherCar = new carConstructor("BMW");
</code></pre>
    <p>üëâ <code>Car</code> (when used as a type) refers to the instance type, while <code>typeof Car</code> refers to the constructor type.</p>

    <hr/>
    <h5>3Ô∏è‚É£ Using <code>InstanceType&lt;T&gt;</code> Utility Type</h5>
    <p>TypeScript provides a built-in utility type <code>InstanceType&lt;T&gt;</code> that extracts the instance type from a class constructor.</p>

    <pre><code>class Employee {
  id: number;
  constructor(id: number) {
    this.id = id;
  }
}

// Extract the instance type from the class constructor
type EmployeeInstance = InstanceType<typeof Employee>;

const emp: EmployeeInstance = new Employee(101);
console.log(emp.id); // ‚úÖ Works perfectly
</code></pre>

    <p><b>Explanation:</b> <code>typeof Employee</code> gives the constructor type, and <code>InstanceType&lt;typeof Employee&gt;</code> gives the instance type (the shape of an object created from that class).</p>

    <hr/>
    <h5>4Ô∏è‚É£ Why Instance Types Matter</h5>
    <ul>
      <li>They ensure that only valid instances are assigned to variables.</li>
      <li>They enable strong typing when working with classes and objects dynamically.</li>
      <li>They help when creating generic functions or factories that return class instances.</li>
    </ul>

    <hr/>
    <h5>5Ô∏è‚É£ Example: Factory Function Returning Instance Type</h5>
    <pre><code>function createInstance<T extends new (...args: any[]) => any>(ctor: T): InstanceType<T> {
  return new ctor(...([] as any));
}

class User {
  username: string = "guest";
}

const u = createInstance(User);
console.log(u.username); // "guest"</code></pre>
    <p>Here, <code>InstanceType&lt;T&gt;</code> helps the compiler infer the correct return type for <code>createInstance()</code>.</p>

    <hr/>
    <h5>6Ô∏è‚É£ Summary</h5>
    <ul>
      <li>Each class in TypeScript has two types: constructor type and instance type.</li>
      <li>The instance type represents the shape of the object created by the class.</li>
      <li>Use <code>typeof</code> to refer to a class‚Äôs constructor type.</li>
      <li>Use <code>InstanceType&lt;typeof ClassName&gt;</code> to extract the instance type.</li>
    </ul>

    <pre><code>type T = InstanceType<typeof MyClass>;</code></pre>

    <p><b>In short:</b> Instance types make your class-based code more precise, reusable, and type-safe in TypeScript.</p>
  `,


      4: `
    <h4>Arrays and Tuples in TypeScript</h4>
    <p>In TypeScript, <b>arrays</b> and <b>tuples</b> are used to store multiple values in a single variable. However, the key difference is that arrays are flexible in length and type (depending on declaration), while tuples have a fixed number of elements and each element has a specific type.</p>

    <hr/>
    <h5>1Ô∏è‚É£ Arrays in TypeScript</h5>
    <p>An array is a collection of values of the same type. You can define arrays in two ways:</p>

    <pre><code>// Using square brackets
let numbers: number[] = [10, 20, 30];

// Using Array generic type
let fruits: Array&lt;string&gt; = ["apple", "banana", "mango"]; or let fruits: string[] = ["apple", "banana", "mango"];
fruits.push("orange"); // ‚úÖ Works
fruits.push(123); // ‚ùå Error: Argument of type 'number' is not assignable to parameter of type 'string'
</code></pre>

    <p>Both are valid and equivalent. You can use array methods like <code>push()</code>, <code>pop()</code>, and <code>map()</code>.</p>

    <pre><code>numbers.push(40);
console.log(numbers); // [10, 20, 30, 40]

fruits.map(f => console.log(f.toUpperCase()));
</code></pre>

    <hr/>
    <h5>2Ô∏è‚É£ Multi-Dimensional Arrays</h5>
    <p>You can create arrays containing other arrays ‚Äî called multi-dimensional arrays.</p>

    <pre><code>let matrix: number[][] = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

console.log(matrix[1][2]); // 6
</code></pre>

    <hr/>
    <h5>3Ô∏è‚É£ Readonly Arrays</h5>
    <p>If you want to make an array immutable (so it cannot be modified), use the <code>readonly</code> keyword.</p>

    <pre><code>const colors: readonly string[] = ["red", "green", "blue"];
// colors.push("yellow"); ‚ùå Error: Property 'push' does not exist on type 'readonly string[]'
</code></pre>

    <p>This ensures the array cannot be changed after creation, improving code safety.</p>

    <hr/>
    <h5>4Ô∏è‚É£ Tuples in TypeScript</h5>
    <p>A tuple is similar to an array but with a fixed number of elements and defined types for each position.</p>

    <pre><code>let person: [string, number] = ["Abhishek", 25];
console.log(person[0]); // "Abhishek"
console.log(person[1]); // 25
</code></pre>

    <p>Here, the first element must always be a <code>string</code> and the second a <code>number</code>. Changing the order or type will cause an error.</p>

    <pre><code>person = [25, "Abhishek"]; // ‚ùå Error: Type 'number' is not assignable to type 'string'</code></pre>

    <hr/>
    <h5>5Ô∏è‚É£ Optional and Readonly Tuple Elements</h5>
    <p>Tuples can have optional elements and readonly restrictions as well:</p>

    <pre><code>// Optional element
let data: [string, number?] = ["Hello"];
console.log(data); // ["Hello"]

// Readonly tuple
const point: readonly [number, number] = [10, 20];
// point[0] = 30; ‚ùå Error
</code></pre>

    <hr/>
    <h5>6Ô∏è‚É£ Tuple Destructuring</h5>
    <p>You can unpack tuple elements into variables easily using destructuring:</p>

    <pre><code>let user: [string, number] = ["Alice", 30];
const [name, age] = user;

console.log(name); // "Alice"
console.log(age);  // 30
</code></pre>

    <hr/>
    <h5>7Ô∏è‚É£ Tuple with Rest Elements (Variable Length)</h5>
    <p>TypeScript allows tuples with variable-length parts using rest elements:</p>

    <pre><code>let team: [string, ...string[]] = ["Captain", "Player1", "Player2", "Player3"];
console.log(team); // ["Captain", "Player1", "Player2", "Player3"]
</code></pre>

    <p>This means the tuple must start with one string (the captain) and can have any number of additional strings after that.</p>

    <hr/>
    <h5>8Ô∏è‚É£ Key Differences: Array vs Tuple</h5>
    <table border="1" cellpadding="6">
      <tr>
        <th>Feature</th>
        <th>Array</th>
        <th>Tuple</th>
      </tr>
      <tr>
        <td>Length</td>
        <td>Can change dynamically</td>
        <td>Fixed length</td>
      </tr>
      <tr>
        <td>Type of Elements</td>
        <td>Usually same type</td>
        <td>Each element can have a different type</td>
      </tr>
      <tr>
        <td>Use Case</td>
        <td>Homogeneous data</td>
        <td>Heterogeneous data</td>
      </tr>
    </table>

    <hr/>
    <h5>9Ô∏è‚É£ Summary</h5>
    <ul>
      <li>Use arrays for lists of items of the same type.</li>
      <li>Use tuples for fixed-size collections with known types for each position.</li>
      <li><code>readonly</code> prevents modification of arrays or tuples.</li>
      <li>Tuples are very useful for returning multiple values from functions.</li>
    </ul>

    <pre><code>// Example: Returning multiple values
function getUser(): [string, number] {
  return ["Bob", 28];
}

const [uname, uage] = getUser();
console.log(uname, uage);
</code></pre>

    <p><b>In short:</b> Arrays are flexible lists, while tuples are structured pairs or sets with fixed type positions ‚Äî both enhance type safety in TypeScript.</p>
  `,
      5: `
    <h4>Object Types and Type Aliases in TypeScript</h4>
    <p>In TypeScript, <b>object types</b> describe the shape (structure) of an object ‚Äî that is, what properties it has and what types those properties hold. TypeScript helps ensure that the objects you use conform to expected shapes, reducing runtime errors.</p>

    <hr/>
    <h5>1Ô∏è‚É£ Basic Object Type</h5>
    <pre><code>let person: { name: string; age: number; isStudent: boolean } = {
  name: "Abhishek",
  age: 25,
  isStudent: false
};</code></pre>

    <p>Here, the variable <code>person</code> must always have:
      <ul>
        <li>a <code>name</code> of type <b>string</b>,</li>
        <li>an <code>age</code> of type <b>number</b>,</li>
        <li>and <code>isStudent</code> of type <b>boolean</b>.</li>
      </ul>
    </p>

    <p>If you try to omit or change any property type, TypeScript will throw an error:</p>
    <pre><code>person.age = "twenty"; // ‚ùå Error: Type 'string' is not assignable to type 'number'</code></pre>

    <hr/>
    <h5>2Ô∏è‚É£ Optional and Readonly Properties</h5>
    <p>Object types can include optional (<code>?</code>) or readonly (<code>readonly</code>) properties.</p>

    <pre><code>type Product = {
  readonly id: number;
  name: string;
  price?: number; // optional
};

let laptop: Product = { id: 1, name: "MacBook" };

laptop.name = "MacBook Air"; // ‚úÖ OK
laptop.id = 2; // ‚ùå Error: Cannot assign to 'id' because it is a read-only property
</code></pre>

    <p>
      ‚úÖ <code>price?</code> means the property is optional.<br/>
      üîí <code>readonly</code> ensures that once assigned, the property cannot be modified.
    </p>

    <hr/>
    <h5>3Ô∏è‚É£ Type Aliases</h5>
    <p>A <b>type alias</b> gives a name to a specific object type (or any other type). This helps avoid repetition and improves readability.</p>

    <pre><code>type User = {
  username: string;
  email: string;
  age: number;
};

let user1: User = {
  username: "john_doe",
  email: "john@example.com",
  age: 30
};

let user2: User = {
  username: "mary_smith",
  email: "mary@example.com",
  age: 25
};
</code></pre>

    <p>Now, instead of repeating the same structure for multiple users, we simply use the alias <code>User</code>.</p>

    <hr/>
    <h5>4Ô∏è‚É£ Nested Object Types</h5>
    <pre><code>type Address = {
  city: string;
  country: string;
};

type Employee = {
  id: number;
  name: string;
  address: Address;
};

const emp: Employee = {
  id: 101,
  name: "Raj",
  address: {
    city: "Bangalore",
    country: "India"
  }
};
</code></pre>

    <p>You can easily nest types to create complex and reusable data structures.</p>

    <hr/>
    <h5>5Ô∏è‚É£ Combining Type Aliases with Union Types</h5>
    <p>Type aliases can also represent a union of types:</p>
    <pre><code>type Status = "active" | "inactive" | "pending";

type Account = {
  id: number;
  name: string;
  status: Status;
};

const acc: Account = { id: 1, name: "Amit", status: "active" }; // ‚úÖ
</code></pre>

    <p>This ensures that only valid string literals are allowed for <code>status</code>.</p>

    <hr/>
    <h5>6Ô∏è‚É£ Difference Between Type Aliases and Interfaces</h5>
    <ul>
      <li><b>Type alias</b> can describe primitives, unions, tuples, and objects.</li>
      <li><b>Interface</b> can describe only object shapes (and can be extended).</li>
      <li>For objects, both work similarly ‚Äî but interfaces are often preferred when designing reusable APIs or class structures.</li>
    </ul>

    <pre><code>// Interface example
interface Person {
  name: string;
  age: number;
}

let p: Person = { name: "Arun", age: 22 };
</code></pre>

    <hr/>
    <h5>7Ô∏è‚É£ Summary</h5>
    <ul>
      <li>Object types define the structure of an object.</li>
      <li>Use <code>?</code> for optional and <code>readonly</code> for immutable properties.</li>
      <li>Use <b>type aliases</b> to reuse complex type definitions.</li>
      <li>Type aliases can describe not just objects, but also primitives, arrays, and unions.</li>
      <li>Interfaces and type aliases can both describe objects ‚Äî choose based on flexibility needs.</li>
    </ul>

    <p><b>In short:</b> Object types and type aliases make your TypeScript code structured, reusable, and easy to maintain.</p>
  `,
      6: `
    <h4>Const Declarations in TypeScript</h4>
    <p>The <code>const</code> keyword in TypeScript (just like in JavaScript) is used to declare variables whose <b>bindings cannot be reassigned</b> after initialization. However, it‚Äôs important to understand that while the reference is constant, the <b>value itself may still be mutable</b> in case of objects and arrays.</p>

    <hr/>
    <h5>1Ô∏è‚É£ Basic Const Declaration</h5>
    <pre><code>const pi = 3.14159;
pi = 3.14; // ‚ùå Error: Cannot assign to 'pi' because it is a constant.
</code></pre>

 <pre><code>type Point = {  x: number; y: number; };
const point: Point = { x: 10, y: 20}; 
point = {x:1, y:1}; // ‚ùå Error
</code></pre>

    <p>
      <ul>
        <li>You must initialize a <code>const</code> variable at the time of declaration.</li>
        <li>Once assigned, you cannot reassign it to another value.</li>
      </ul>
    </p>

    <hr/>
    <h5>2Ô∏è‚É£ Const with Objects</h5>
    <p>The <code>const</code> binding prevents reassignment, but the object‚Äôs internal properties can still be changed.</p>
    <pre><code>const user = { name: "Abhi", age: 25 };

// Allowed: modifying object properties
user.age = 26; // ‚úÖ Works fine

// Not allowed: reassigning the object reference
user = { name: "New User", age: 30 }; // ‚ùå Error
</code></pre>

    <p><b>Explanation:</b> The reference <code>user</code> is constant, but the object itself is still mutable.</p>

    <hr/>
    <h5>3Ô∏è‚É£ Const with Arrays</h5>
    <p>Similarly, <code>const</code> arrays can be modified but not reassigned.</p>
    <pre><code>const fruits = ["apple", "banana"];
fruits.push("mango"); // ‚úÖ Allowed
fruits[0] = "grape";  // ‚úÖ Allowed

fruits = ["kiwi", "orange"]; // ‚ùå Error: cannot reassign
</code></pre>

    <p>This means that <code>const</code> ensures the variable always points to the same array, but the array contents can change.</p>

    <hr/>
    <h5>4Ô∏è‚É£ Const vs Let vs Var</h5>
    <table border="1" cellspacing="0" cellpadding="6" style="border-collapse:collapse; border-color:#333;">
      <thead>
        <tr>
          <th>Keyword</th>
          <th>Scope</th>
          <th>Can Reassign?</th>
          <th>Can Redeclare?</th>
          <th>Hoisted?</th>
        </tr>
      </thead>
      <tbody>
        <tr><td><b>var</b></td><td>Function-scoped</td><td>‚úÖ Yes</td><td>‚úÖ Yes</td><td>‚úÖ Yes (initialized as undefined)</td></tr>
        <tr><td><b>let</b></td><td>Block-scoped</td><td>‚úÖ Yes</td><td>‚ùå No</td><td>‚úÖ Yes (not initialized)</td></tr>
        <tr><td><b>const</b></td><td>Block-scoped</td><td>‚ùå No</td><td>‚ùå No</td><td>‚úÖ Yes (not initialized)</td></tr>
      </tbody>
    </table>

    <p><b>Summary:</b> Always prefer <code>const</code> for variables whose value shouldn‚Äôt change, and <code>let</code> when you need to reassign later. Avoid <code>var</code> in modern TypeScript/JavaScript code.</p>

    <hr/>
    <h5>5Ô∏è‚É£ Const and Type Inference</h5>
    <p>When using <code>const</code>, TypeScript infers literal types for the variable. For example:</p>
    <pre><code>const name = "Abhi";
// inferred type: "Abhi" (a string literal type)

let city = "Delhi";
// inferred type: string (can hold any string)
</code></pre>

    <p>This difference helps TypeScript provide stronger type checking with <code>const</code>.</p>

    <hr/>
    <h5>6Ô∏è‚É£ Const with Type Annotations</h5>
    <p>You can still explicitly annotate types, though it‚Äôs rarely needed since TypeScript infers them automatically.</p>
    <pre><code>const count: number = 10;
const isActive: boolean = true;
</code></pre>

    <p>TypeScript will enforce these types strictly at compile time.</p>

    <hr/>
    <h5>7Ô∏è‚É£ Const Assertions (<code>as const</code>)</h5>
    <p>The <code>as const</code> assertion makes an object or array completely immutable ‚Äî even its inner values become readonly.</p>
    <pre><code>const colors = ["red", "green", "blue"] as const;
// inferred as readonly ["red", "green", "blue"]

const user = {
  name: "Abhi",
  age: 25
} as const;

// user.age = 30; ‚ùå Error: Cannot assign to 'age' because it is a read-only property.
</code></pre>

    <p><b>Use Case:</b> When you want to define fixed configuration data or enum-like constants.</p>

    <hr/>
    <h5>üß© Summary</h5>
    <ul>
      <li><code>const</code> creates read-only bindings ‚Äî you can‚Äôt reassign them.</li>
      <li>Objects and arrays declared with <code>const</code> are mutable (unless you use <code>as const</code>).</li>
      <li><code>const</code> variables are block-scoped and must be initialized immediately.</li>
      <li>Prefer <code>const</code> over <code>let</code> whenever reassignment isn‚Äôt needed.</li>
      <li><code>as const</code> provides literal immutability for objects and arrays.</li>
    </ul>

    <p><b>In short:</b> Use <code>const</code> to ensure immutability of bindings and to help TypeScript infer the most specific types for your variables.</p>
  `,
      7: `
    <h4>Functions in TypeScript</h4>
    <p>Functions are one of the most important building blocks in TypeScript. TypeScript adds strong <b>type checking</b> for function parameters, return values, and optional/default arguments ‚Äî making your code safer and easier to maintain.</p>

    <hr/>
    <h5>1Ô∏è‚É£ Function Basics</h5>
    <p>You can define function parameter and return types in TypeScript:</p>
    <pre><code>function add(a: number, b: number): number {
  return a + b;
}

let sum = add(10, 5); // ‚úÖ 15
</code></pre>

    <p>Here:
      <ul>
        <li><code>a</code> and <code>b</code> are parameters of type <b>number</b>.</li>
        <li>The return type is also <b>number</b>.</li>
        <li>If you return anything else (like a string), TypeScript will throw a compile-time error.</li>
      </ul>
    </p>

    <hr/>
    <h5>2Ô∏è‚É£ Type Inference</h5>
    <p>If you omit the return type, TypeScript infers it automatically:</p>
    <pre><code>function greet(name: string) {
  return "Hello " + name;
}

let msg = greet("Abhi"); // inferred as string
</code></pre>

    <p>TypeScript knows that <code>greet()</code> returns a string because of the <code>return</code> statement.</p>

    <hr/>
    <h5>3Ô∏è‚É£ Optional and Default Parameters</h5>
    <p>You can make parameters optional or assign them default values.</p>
    <pre><code>function multiply(a: number, b?: number): number {
  return b ? a * b : a;
}

console.log(multiply(5)); // ‚úÖ 5
console.log(multiply(5, 3)); // ‚úÖ 15

function greetUser(name: string = "Guest"): string {
  return "Welcome, " + name;
}

console.log(greetUser()); // ‚úÖ Welcome, Guest
</code></pre>

    <p>
      <ul>
        <li><code>b?: number</code> ‚Üí optional parameter.</li>
        <li><code>name: string = "Guest"</code> ‚Üí default parameter value.</li>
      </ul>
    </p>

    <hr/>
    <h5>4Ô∏è‚É£ Function Type Expressions</h5>
    <p>You can store a function type in a variable using a function type expression.</p>
    <pre><code>let addNumbers: (x: number, y: number) => number;

addNumbers = function (a, b) {
  return a + b;
};

console.log(addNumbers(4, 6)); // ‚úÖ 10
</code></pre>

    <p>This syntax clearly defines what type of arguments and return value a function must have.</p>

    <hr/>
    <h5>5Ô∏è‚É£ Arrow Functions</h5>
    <p>Arrow functions in TypeScript are similar to JavaScript, with full type support:</p>
    <pre><code>const divide = (a: number, b: number): number => a / b;

console.log(divide(10, 2)); // ‚úÖ 5
</code></pre>

    <p>You can omit parameter types when they can be inferred:</p>
    <pre><code>const greet = (msg = "Hello") => console.log(msg);</code></pre>

    <hr/>
    <h5>6Ô∏è‚É£ Void and Never Return Types</h5>
    <p><b>void</b> means a function doesn‚Äôt return any value.</p>
    <pre><code>function logMessage(message: string): void {
  console.log("INFO:", message);
}</code></pre>

    <p><b>never</b> means a function never successfully returns (like it always throws an error or loops infinitely):</p>
    <pre><code>function throwError(msg: string): never {
  throw new Error(msg);
}
</code></pre>

    <hr/>
    <h5>7Ô∏è‚É£ Rest Parameters</h5>
    <p>Use rest parameters when you don‚Äôt know how many arguments will be passed:</p>
    <pre><code>function sumAll(...numbers: number[]): number {
  return numbers.reduce((acc, n) => acc + n, 0);
}

console.log(sumAll(1, 2, 3, 4)); // ‚úÖ 10
</code></pre>

    <p>The rest parameter <code>...numbers</code> is an array of numbers.</p>

    <hr/>
    <h5>8Ô∏è‚É£ Anonymous and Callback Functions</h5>
    <p>You can define functions inline and pass them as arguments:</p>
    <pre><code>function processData(data: number[], callback: (num: number) => void) {
  for (let n of data) callback(n);
}

processData([10, 20, 30], (n) => console.log(n * 2));
</code></pre>

    <p>The callback is explicitly typed, ensuring the parameter <code>num</code> is a number.</p>

    <hr/>
    <h5>9Ô∏è‚É£ Function Overloading</h5>
    <p>TypeScript supports defining multiple function signatures for the same function (overloading):</p>
    <pre><code>function display(value: string): void;
function display(value: number): void;
function display(value: any): void {
  console.log("Value:", value);
}

display("Hello");
display(42);
</code></pre>

    <p>Overloads allow one function to handle different argument types safely.</p>

    <hr/>
    <h5>üîü Summary</h5>
    <ul>
      <li>Functions in TypeScript have strict type checking for parameters and return values.</li>
      <li>Parameters can be optional (<code>?</code>), have default values, or be rest parameters (<code>...</code>).</li>
      <li>Use <code>void</code> for functions without return values, and <code>never</code> for those that never return.</li>
      <li>Arrow functions and callbacks support full typing.</li>
      <li>Overloading allows one function to handle multiple input types.</li>
    </ul>

    <p><b>In short:</b> TypeScript‚Äôs function typing system helps catch errors early, ensures predictable behavior, and makes your code more readable and maintainable.</p>
  `,
  8: `
  <h4>Structural Typing in TypeScript</h4>
  <p><b>Structural Typing</b> means that TypeScript compares types based on their <b>structure or shape</b>, not on their name or declaration. If two types have the same set of properties with the same types, they are considered compatible.</p>

  <hr/>
  <h5>1Ô∏è‚É£ Example: Shape-Based Compatibility</h5>
  <pre><code>type Point = { x: number; y: number };
type Coordinate = { x: number; y: number };

let p1: Point = { x: 10, y: 20 };
let c1: Coordinate = { x: 10, y: 20 };

p1 = c1; // ‚úÖ Works because structure matches
  </code></pre>
  <p>Even though <code>Point</code> and <code>Coordinate</code> are different type names, they are compatible because their structure is identical.</p>

  <hr/>
  <h5>2Ô∏è‚É£ Example: Extra and Missing Properties</h5>
  <pre><code>type Point2D = { x: number; y: number };
type Point3D = { x: number; y: number; z: number };

let twoD: Point2D = { x: 1, y: 2 };
let threeD: Point3D = { x: 1, y: 2, z: 3 };

twoD = threeD; // ‚úÖ Allowed (extra property ignored)
threeD = twoD; // ‚ùå Error: Property 'z' is missing
  </code></pre>
  <p>TypeScript allows assigning objects with extra properties to less specific types, but not the other way around.</p>

  <hr/>
  <h5>3Ô∏è‚É£ With Interfaces</h5>
  <pre><code>interface Person {
  name: string;
  age: number;
}

let user = { name: "Abhi", age: 25, city: "Delhi" };
let person: Person = user; // ‚úÖ Works ‚Äî structure matches
  </code></pre>
  <p>Interfaces also follow structural typing rules. As long as the structure matches, the assignment is valid.</p>

  <hr/>
  <h5>4Ô∏è‚É£ Why Structural Typing?</h5>
  <ul>
    <li>More flexible and JavaScript-friendly.</li>
    <li>Supports <b>duck typing</b> ‚Äî ‚ÄúIf it looks like a duck and quacks like a duck, it‚Äôs a duck.‚Äù</li>
    <li>Reduces the need for explicit inheritance or interface implementation.</li>
  </ul>

  <hr/>
  <h5>üß† Summary</h5>
  <ul>
    <li>TypeScript uses <b>structural typing</b>, not nominal typing (like Java or C#).</li>
    <li>Compatibility is based on <b>shape (properties and types)</b>, not names.</li>
    <li>Encourages flexible, shape-based programming.</li>
  </ul>
  `,
  9: `
  <h4>Classes in TypeScript</h4>
  <p>Classes in TypeScript are blueprints for creating objects with properties and methods. They bring object-oriented programming (OOP) features like <b>encapsulation, inheritance, and polymorphism</b> to JavaScript.</p>

  <hr/>
  <h5>1Ô∏è‚É£ Basic Class Example</h5>
  <pre><code>class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet(): void {
    console.log(\`Hello, my name is \${this.name}\`);
  }
}

const user = new Person("Abhi", 25);
user.greet(); // Output: Hello, my name is Abhi
  </code></pre>

  <ul>
    <li><code>constructor</code> initializes class properties.</li>
    <li><code>this</code> refers to the current instance.</li>
    <li>TypeScript ensures property and method type safety.</li>
  </ul>

  <hr/>
  <h5>2Ô∏è‚É£ Access Modifiers</h5>
  <p>Access modifiers control the visibility of class members:</p>
  <ul>
    <li><b>public</b> ‚Äì accessible anywhere (default).</li>
    <li><b>private</b> ‚Äì accessible only inside the class.</li>
    <li><b>protected</b> ‚Äì accessible inside the class and subclasses.</li>
  </ul>

  <pre><code>class Employee {
  private salary: number;
  protected department: string;

  constructor(salary: number, department: string) {
    this.salary = salary;
    this.department = department;
  }
}

class Manager extends Employee {
  getDepartment() {
    console.log(\`Department: \${this.department}\`);
  }
}
  </code></pre>

  <hr/>
  <h5>3Ô∏è‚É£ Readonly Properties</h5>
  <p>Readonly properties can only be assigned during declaration or in the constructor.</p>
  <pre><code>class Car {
  readonly model: string;

  constructor(model: string) {
    this.model = model;
  }
}

const myCar = new Car("Tesla");
// myCar.model = "BMW"; // ‚ùå Error: Cannot assign to 'model' because it is a read-only property
  </code></pre>

  <hr/>
  <h5>4Ô∏è‚É£ Inheritance</h5>
  <p>A class can extend another class to reuse properties and methods.</p>
  <pre><code>class Animal {
  move() {
    console.log("Moving...");
  }
}

class Dog extends Animal {
  bark() {
    console.log("Woof!");
  }
}

const dog = new Dog();
dog.move(); // ‚úÖ Moving...
dog.bark(); // ‚úÖ Woof!
  </code></pre>

  <hr/>
  <h5>5Ô∏è‚É£ Getters and Setters</h5>
  <p>Use <code>get</code> and <code>set</code> to control access to private properties.</p>
  <pre><code>class Circle {
  private _radius: number = 0;

  get radius(): number {
    return this._radius;
  }

  set radius(value: number) {
    if (value > 0) this._radius = value;
    else throw new Error("Radius must be positive");
  }
}

const c = new Circle();
c.radius = 10;
console.log(c.radius); // 10
  </code></pre>

  <hr/>
  <h5>6Ô∏è‚É£ Parameter Properties (Shorthand)</h5>
  <p>TypeScript allows declaring and initializing properties directly in the constructor.</p>
  <pre><code>class Student {
  constructor(public name: string, private rollNo: number) {}

  display() {
    console.log(\`Name: \${this.name}, Roll No: \${this.rollNo}\`);
  }
}

const s = new Student("Abhi", 101);
s.display();
  </code></pre>

  <hr/>
  <h5>üß† Summary</h5>
  <ul>
    <li>Classes define object structure and behavior.</li>
    <li>Supports OOP features like encapsulation, inheritance, and access control.</li>
    <li>Use <code>public</code>, <code>private</code>, <code>protected</code>, and <code>readonly</code> for data safety.</li>
    <li>Parameter properties simplify class constructors.</li>
  </ul>
  `,
  10: `
  <h4>Target Compiler Option in TypeScript</h4>
  <p>The <code>target</code> compiler option in TypeScript defines the version of JavaScript that the TypeScript compiler (<code>tsc</code>) should output after compilation.</p>

  <hr/>
  <h5>1Ô∏è‚É£ What is the <code>target</code> option?</h5>
  <p>When you compile a TypeScript file, it‚Äôs converted into JavaScript. The <code>target</code> option tells the compiler which version of JavaScript to generate ‚Äî for example, ES5, ES6 (ES2015), ES2017, etc.</p>

  <pre><code>{
  "compilerOptions": {
    "target": "ES6"
  }
}
  </code></pre>

  <p>This means that TypeScript will compile modern syntax (like <code>let</code>, <code>const</code>, arrow functions, classes, etc.) into JavaScript compatible with the ES6 standard.</p>

  <hr/>
  <h5>2Ô∏è‚É£ Common Target Options</h5>
  <table border="1" cellspacing="0" cellpadding="6">
    <tr><th>Target</th><th>Description</th></tr>
    <tr><td><b>ES3</b></td><td>Oldest supported version, compatible with very old browsers.</td></tr>
    <tr><td><b>ES5</b></td><td>Commonly used for maximum browser compatibility.</td></tr>
    <tr><td><b>ES6 / ES2015</b></td><td>Supports modern features like classes, arrow functions, and template literals.</td></tr>
    <tr><td><b>ES2017 / ES2018 / ESNext</b></td><td>Used when you want to use the latest JavaScript features (Node.js or modern browsers).</td></tr>
  </table>

  <hr/>
  <h5>3Ô∏è‚É£ Example</h5>
  <p>TypeScript code:</p>
  <pre><code>const greet = () => console.log("Hello TypeScript!");
  </code></pre>

  <p>Compiled output with <b>target: "ES5"</b>:</p>
  <pre><code>var greet = function () { return console.log("Hello TypeScript!"); };
  </code></pre>

  <p>Compiled output with <b>target: "ES6"</b>:</p>
  <pre><code>const greet = () => console.log("Hello TypeScript!");
  </code></pre>

  <p>As you can see, the <code>target</code> determines which JavaScript syntax is used in the output.</p>

  <hr/>
  <h5>4Ô∏è‚É£ How to Set the Target</h5>
  <p>You can set the target in two ways:</p>
  <ul>
    <li><b>Option 1:</b> Inside <code>tsconfig.json</code></li>
    <pre><code>{
  "compilerOptions": {
    "target": "ES6"
  }
}
    </code></pre>

    <li><b>Option 2:</b> Through the command line</li>
    <pre><code>npx tsc --target ES6</code></pre>
  </ul>

  <hr/>
  <h5>üß† Summary</h5>
  <ul>
    <li>The <code>target</code> option controls the version of JavaScript emitted by the TypeScript compiler.</li>
    <li>Use <code>ES5</code> for older browsers, <code>ES6+</code> for modern environments.</li>
    <li>Set <code>target</code> in <code>tsconfig.json</code> or via command line.</li>
    <li>Choosing the right target ensures compatibility and performance.</li>
  </ul>
  `, 
  
  11: `
  <h4>Generics in TypeScript</h4>
  <p>Generics allow you to create reusable and flexible components that can work with multiple data types instead of a single one. They provide type safety while maintaining flexibility.</p>

  <hr/>
  <h5>1Ô∏è‚É£ Why Use Generics?</h5>
  <p>Without generics, you may have to create multiple versions of the same function or class for different data types, or use <code>any</code> which removes type safety.</p>

  <p>Example using <code>any</code> (‚ùå unsafe):</p>
  <pre><code>function identity(value: any): any {
  return value;
}

let num = identity(10);
let str = identity("Hello");
// No type checking - unsafe!
</code></pre>

  <p>Now, using <b>Generics</b> (‚úÖ safe):</p>
  <pre><code>function identity&lt;T&gt;(value: T): T {
  return value;
}

let num = identity&lt;number&gt;(10);
let str = identity&lt;string&gt;("Hello");
</code></pre>

  <p>‚úîÔ∏è Here, <code>&lt;T&gt;</code> is a generic type variable. TypeScript infers or enforces the correct type automatically.</p>

  <hr/>
  <h5>2Ô∏è‚É£ Generic Functions</h5>
  <p>Write a single function that works with any type, while maintaining type safety.</p>

  <pre><code>function printArray&lt;T&gt;(items: T[]): void {
  items.forEach(item =&gt; console.log(item));
}

printArray&lt;number&gt;([1, 2, 3]);
printArray&lt;string&gt;(["a", "b", "c"]);
</code></pre>

  <p>This makes your function reusable for any data type.</p>

  <hr/>
  <h5>3Ô∏è‚É£ Generic Interfaces</h5>
  <pre><code>interface Box&lt;T&gt; {
  content: T;
}

let box1: Box&lt;string&gt; = { content: "Books" };
let box2: Box&lt;number&gt; = { content: 42 };
</code></pre>

  <p>‚úîÔ∏è The same interface can handle multiple data types using generics.</p>

  <hr/>
  <h5>4Ô∏è‚É£ Generic Classes</h5>
  <pre><code>class DataStore&lt;T&gt; {
  private data: T[] = [];

  addItem(item: T): void {
    this.data.push(item);
  }

  getItems(): T[] {
    return this.data;
  }
}

const stringStore = new DataStore&lt;string&gt;();
stringStore.addItem("Hello");

const numberStore = new DataStore&lt;number&gt;();
numberStore.addItem(123);
</code></pre>

  <p>‚úîÔ∏è The same class works for different types with type safety.</p>

  <hr/>
  <h5>5Ô∏è‚É£ Generic Queue Example</h5>
  <p>A practical example using a Queue data structure implemented with generics.</p>

  <pre><code>class Queue&lt;T&gt; {
  private items: T[] = [];

  enqueue(item: T): void {
    this.items.push(item);
  }

  dequeue(): T | undefined {
    return this.items.shift();
  }

  peek(): T | undefined {
    return this.items[0];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }
}

const numberQueue = new Queue&lt;number&gt;();
numberQueue.enqueue(10);
numberQueue.enqueue(20);
console.log(numberQueue.dequeue()); // 10

const stringQueue = new Queue&lt;string&gt;();
stringQueue.enqueue("A");
stringQueue.enqueue("B");
console.log(stringQueue.peek()); // A
</code></pre>

  <p>‚úîÔ∏è The same queue logic works for <code>number</code>, <code>string</code>, or any custom type.</p>

  <hr/>
  <h5>6Ô∏è‚É£ Generic Constraints</h5>
  <p>Sometimes, you may want to restrict the types that can be used with a generic.</p>

  <pre><code>interface HasLength {
  length: number;
}

function logLength&lt;T extends HasLength&gt;(item: T): void {
  console.log(item.length);
}

logLength("Hello");     // ‚úÖ Works
logLength([1, 2, 3]);   // ‚úÖ Works
// logLength(123); ‚ùå Error
</code></pre>

  <p>‚úîÔ∏è <code>T extends HasLength</code> ensures that only types with a <code>length</code> property are allowed.</p>

  <hr/>
  <h5>7Ô∏è‚É£ Default Generic Type</h5>
  <pre><code>function identityWithDefault&lt;T = string&gt;(value: T): T {
  return value;
}

console.log(identityWithDefault("Hello"));
console.log(identityWithDefault(42));
</code></pre>

  <hr/>
  <h5>üß† Summary</h5>
  <ul>
    <li>Generics provide type safety and flexibility.</li>
    <li>They work with functions, interfaces, and classes.</li>
    <li>Use <code>&lt;T&gt;</code> as a placeholder for any data type.</li>
    <li>Generic constraints (<code>extends</code>) allow limited type control.</li>
    <li>Default generic types simplify usage.</li>
    <li>Queue example shows how generics help build reusable data structures.</li>
  </ul>

  <p><b>Generics = Reusability + Type Safety ‚úÖ</b></p>
  `,
  12: `
  <h4>Special Types in TypeScript: <code>any</code> and <code>unknown</code></h4>
  <p>TypeScript provides special types like <code>any</code> and <code>unknown</code> for handling values whose types are not known at compile time.</p>

  <hr/>
  <h5>1Ô∏è‚É£ The <code>any</code> Type</h5>
  <p>The <b><code>any</code></b> type disables TypeScript‚Äôs type checking. It tells the compiler to skip type safety for that variable.</p>

  <pre><code>let value: any = 10;
value = "Hello";
value = true;
value = { name: "Abhi" };

console.log(value.toUpperCase()); // ‚úÖ No error, but may fail at runtime
</code></pre>

  <p>‚úîÔ∏è <code>any</code> gives flexibility but removes all compile-time type safety.</p>

  <p>‚ùå <b>Disadvantage:</b> Using <code>any</code> frequently defeats the purpose of TypeScript‚Äôs type system.</p>

  <hr/>
  <h5>2Ô∏è‚É£ The <code>unknown</code> Type</h5>
  <p>The <b><code>unknown</code></b> type is a safer alternative to <code>any</code>. It represents a value that could be anything, but you must perform type checking before using it.</p>

  <pre><code>let data: unknown;
data = "Hello";
data = 42;
data = { name: "Abhi" };

// console.log(data.toUpperCase()); ‚ùå Error: Object is of type 'unknown'

if (typeof data === "string") {
  console.log(data.toUpperCase()); // ‚úÖ Safe
}
</code></pre>

  <p>‚úîÔ∏è <code>unknown</code> forces you to check the type before accessing its properties or methods.</p>

  <hr/>
  <h5>3Ô∏è‚É£ Difference Between <code>any</code> and <code>unknown</code></h5>
  <table border="1" cellpadding="6">
    <tr>
      <th>Feature</th>
      <th><code>any</code></th>
      <th><code>unknown</code></th>
    </tr>
    <tr>
      <td>Type Checking</td>
      <td>Disabled ‚ùå</td>
      <td>Required ‚úÖ</td>
    </tr>
    <tr>
      <td>Assign to Other Types</td>
      <td>Allowed freely</td>
      <td>Not allowed without checks</td>
    </tr>
    <tr>
      <td>Safety</td>
      <td>Unsafe (runtime errors possible)</td>
      <td>Safe (forces type checking)</td>
    </tr>
    <tr>
      <td>Example Usage</td>
      <td>For quick prototyping</td>
      <td>For values from dynamic sources (e.g. API data)</td>
    </tr>
  </table>

  <hr/>
  <h5>4Ô∏è‚É£ Type Narrowing Example with <code>unknown</code></h5>
  <pre><code>function processData(value: unknown) {
  if (typeof value === "string") {
    console.log(value.toUpperCase());
  } else if (typeof value === "number") {
    console.log(value.toFixed(2));
  } else {
    console.log("Unknown type");
  }
}

processData("TypeScript");
processData(123.456);
processData(true);
</code></pre>

  <hr/>
  <h5>üß† Summary</h5>
  <ul>
    <li><code>any</code> disables all type checking ‚Äì use sparingly.</li>
    <li><code>unknown</code> is type-safe ‚Äì you must narrow down the type before use.</li>
    <li>Prefer <code>unknown</code> when dealing with uncertain types (e.g., user input or API data).</li>
  </ul>

  <p><b>‚úÖ Best Practice:</b> Avoid <code>any</code> unless absolutely necessary ‚Äî prefer <code>unknown</code> for safety and clarity.</p>
  `,
  13: `
  <h4>JavaScript to TypeScript</h4>
  <p>TypeScript is a superset of JavaScript, which means <strong>any valid JavaScript code is also valid TypeScript code.</strong>  
  You can gradually migrate your existing JavaScript projects to TypeScript by adding type annotations and configuration.</p>

  <hr/>
  <h5>1Ô∏è‚É£ Step 1: Rename <code>.js</code> Files to <code>.ts</code></h5>
  <p>Start by renaming your existing JavaScript files from <code>.js</code> to <code>.ts</code>.  
  TypeScript will begin analyzing your code and highlight potential issues or missing types.</p>

  <pre><code>// JavaScript
function add(a, b) {
  return a + b;
}

// TypeScript
function add(a: number, b: number): number {
  return a + b;
}
</code></pre>

  <p>Adding type annotations (<code>: number</code>) helps catch type errors at compile time.</p>

  <hr/>
  <h5>2Ô∏è‚É£ Step 2: Add a <code>tsconfig.json</code></h5>
  <p>Use the TypeScript compiler to create a configuration file:</p>
  <pre><code>npx tsc --init</code></pre>
  <p>This creates a <code>tsconfig.json</code> file to control compiler settings like the output directory, target ECMAScript version, and strictness.</p>

  <hr/>
  <h5>3Ô∏è‚É£ Step 3: Enable Strict Type Checking</h5>
  <p>In <code>tsconfig.json</code>, enable strict mode for maximum safety:</p>
  <pre><code>{
  "compilerOptions": {
    "strict": true
  }
}</code></pre>

  <p>Strict mode ensures that all variables, functions, and parameters have explicit types.</p>

  <hr/>
  <h5>4Ô∏è‚É£ Step 4: Add Type Annotations</h5>
  <p>Use TypeScript‚Äôs type system to add safety to your variables and functions.</p>

  <pre><code>// JavaScript
let message = "Hello, JS!";

// TypeScript
let message: string = "Hello, TS!";
</code></pre>

  <p>You can also define object shapes and arrays:</p>
  <pre><code>let user: { name: string; age: number } = { name: "Abhi", age: 25 };
let numbers: number[] = [1, 2, 3];
</code></pre>

  <hr/>
  <h5>5Ô∏è‚É£ Step 5: Add Interfaces or Type Aliases</h5>
  <p>Use <code>interface</code> or <code>type</code> to define reusable structures.</p>
  <pre><code>interface User {
  name: string;
  email: string;
}

const newUser: User = { name: "Abhi", email: "abhi@example.com" };
</code></pre>

  <hr/>
  <h5>6Ô∏è‚É£ Step 6: Compile to JavaScript</h5>
  <p>Compile your TypeScript file to JavaScript using:</p>
  <pre><code>npx tsc</code></pre>
  <p>This generates <code>.js</code> files that can run in any JavaScript environment.</p>

  <hr/>
  <h5>7Ô∏è‚É£ Step 7: Gradual Migration Approach</h5>
  <p>TypeScript supports gradual adoption. You can mix <code>.js</code> and <code>.ts</code> files in the same project.</p>
  <pre><code>{
  "compilerOptions": {
    "allowJs": true,
    "checkJs": true
  }
}</code></pre>

  <p>This lets you convert files one by one at your own pace.</p>

  <hr/>
  <h5>8Ô∏è‚É£ Benefits of Migrating to TypeScript</h5>
  <ul>
    <li>‚úîÔ∏è Early error detection at compile time</li>
    <li>‚úîÔ∏è Better code auto-completion and documentation</li>
    <li>‚úîÔ∏è Easier refactoring</li>
    <li>‚úîÔ∏è Clearer intent with static typing</li>
  </ul>

  <hr/>
  <h5>üß© Example</h5>
  <pre><code>// JavaScript
function greet(name) {
  return "Hello " + name.toUpperCase();
}

// TypeScript
function greet(name: string): string {
  return "Hello " + name.toUpperCase();
}

console.log(greet("Abhi"));
</code></pre>

  <hr/>
  <h5>üß† Summary</h5>
  <ul>
    <li><b>TypeScript = JavaScript + Type System</b></li>
    <li>Start migration by renaming <code>.js</code> to <code>.ts</code>.</li>
    <li>Add type annotations, enable strict mode, and compile to JavaScript.</li>
    <li>Gradual adoption makes migration easy and low-risk.</li>
  </ul>

  <p><b>‚úÖ Result:</b> Safer, more maintainable, and self-documenting JavaScript code.</p>
  `,
  14: `
  <h4>Creating a React + TypeScript Frontend Project</h4>
  <p>TypeScript and React work perfectly together ‚Äî TypeScript provides static typing, better IntelliSense, and early error detection while React handles the UI logic.</p>
  <p>Let‚Äôs see how to create and configure a React project with TypeScript step by step.</p>

  <hr/>
  <h5>1Ô∏è‚É£ Step 1: Create a New React Project with TypeScript Template</h5>
  <pre><code>npx create-react-app my-react-app --template typescript</code></pre>
  <p>This command sets up a ready-to-use React application with TypeScript configuration built in.</p>

  <p>After creation, navigate to your project folder:</p>
  <pre><code>cd my-react-app
npm start</code></pre>
  <p>This launches the development server and opens your app in the browser at <code>http://localhost:3000</code>.</p>

  <hr/>
  <h5>2Ô∏è‚É£ Step 2: Project Structure</h5>
  <pre><code>my-react-app/
‚îú‚îÄ‚îÄ node_modules/
‚îú‚îÄ‚îÄ public/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ App.tsx
‚îÇ   ‚îú‚îÄ‚îÄ index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ react-app-env.d.ts
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Hello.tsx
‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ README.md</code></pre>

  <p>The <code>.tsx</code> extension allows JSX syntax in TypeScript files.</p>

  <hr/>
  <h5>3Ô∏è‚É£ Step 3: Understanding TypeScript in React</h5>
  <p>TypeScript helps define prop types and state shapes for React components.</p>

  <pre><code>// src/components/Hello.tsx
import React from "react";

type HelloProps = {
  name: string;
  age?: number; // Optional prop
};

const Hello: React.FC&lt;HelloProps&gt; = ({ name, age }) => {
  return (
    &lt;div&gt;
      &lt;h2&gt;Hello, {name}!&lt;/h2&gt;
      {age && &lt;p&gt;You are {age} years old.&lt;/p&gt;}
    &lt;/div&gt;
  );
};

export default Hello;
</code></pre>

  <p>Then import and use it in <code>App.tsx</code>:</p>
  <pre><code>import React from "react";
import Hello from "./components/Hello";

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;Welcome to React + TypeScript&lt;/h1&gt;
      &lt;Hello name="Abhishek" age={25} /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>

  <hr/>
  <h5>4Ô∏è‚É£ Step 4: Working with useState and useEffect Hooks</h5>
  <pre><code>import React, { useState, useEffect } from "react";

const Counter: React.FC = () => {
  const [count, setCount] = useState&lt;number&gt;(0);

  useEffect(() => {
    document.title = \`Count: \${count}\`;
  }, [count]);

  return (
    &lt;div&gt;
      &lt;h2&gt;Count: {count}&lt;/h2&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Counter;
</code></pre>

  <p>Type annotations like <code>useState&lt;number&gt;</code> ensure that <code>count</code> can only be a number ‚Äî preventing common type errors.</p>

  <hr/>
  <h5>5Ô∏è‚É£ Step 5: TypeScript Configuration in React</h5>
  <p>TypeScript React projects include a <code>tsconfig.json</code> file by default.</p>

  <pre><code>{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "jsx": "react-jsx",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}</code></pre>
  <p>This enables strict typing and React‚Äôs new JSX transform.</p>

  <hr/>
  <h5>6Ô∏è‚É£ Step 6: Adding Interfaces and Types for Props</h5>
  <pre><code>interface Product {
  id: number;
  name: string;
  price: number;
}

type ProductListProps = {
  items: Product[];
};

const ProductList: React.FC&lt;ProductListProps&gt; = ({ items }) =&gt; (
  &lt;ul&gt;
    {items.map(item =&gt; (
      &lt;li key={item.id}&gt;
        {item.name} - ‚Çπ{item.price}
      &lt;/li&gt;
    ))}
  &lt;/ul&gt;
);</code></pre>

  <p>Interfaces and types make React code self-documenting and error-free.</p>

  <hr/>
  <h5>7Ô∏è‚É£ Step 7: Building and Deploying</h5>
  <p>To build your app for production:</p>
  <pre><code>npm run build</code></pre>
  <p>This generates an optimized, minified build in the <code>build/</code> folder ‚Äî ready to be deployed.</p>

  <hr/>
  <h5>üß† Summary</h5>
  <ul>
    <li>React + TypeScript provides strong typing and better developer experience.</li>
    <li>Use <code>tsx</code> for React components with JSX syntax.</li>
    <li>Always type props, state, and hooks for better readability and maintainability.</li>
    <li><b>Create React App</b> with <code>--template typescript</code> gives you everything preconfigured.</li>
  </ul>

  <p><b>‚úÖ Result:</b> A robust, type-safe React project built using TypeScript ‚Äî ready for scalable frontend development.</p>
  `,
  15: `
  <h4>Type Assertions in TypeScript</h4>
  <p>Type assertions tell the TypeScript compiler to treat a value as a specific type. It does not change the runtime behavior of the code; it only affects type checking.</p>

  <p>Type assertions are useful when you, as a developer, have more information about the type of a value than TypeScript can infer.</p>

  <h5>Syntax</h5>
  <pre><code>
  // Using 'as' syntax (recommended)
  let value: unknown = "Hello TypeScript";
  let strLength: number = (value as string).length;

  // Using angle-bracket syntax (older form)
  let strLength2: number = (&lt;string&gt;value).length; // This form is not allowed in .tsx files as <> is used for JSX syntax.
  </code></pre>

  <h5>Example</h5>
  <pre><code>
  // Example: DOM element type assertion
  const inputElement = document.querySelector("input") as HTMLInputElement;
  inputElement.value = "TypeScript Rocks!";
  </code></pre>

  <p>Here, TypeScript doesn't know that <code>document.querySelector()</code> returns an input element. By asserting its type, we can safely access input-specific properties like <code>value</code>.</p>

  <h5>Non-null Assertion Operator</h5>
  <p>Use <code>!</code> to tell TypeScript that a value is not <code>null</code> or <code>undefined</code>.</p>
  <pre><code>
  const element = document.getElementById("title")!;
  element.innerHTML = "Welcome!";
  </code></pre>

  <h5>Type Assertions vs Type Casting</h5>
  <ul>
    <li>Type Assertions exist only in TypeScript and are removed during compilation.</li>
    <li>They do not change the actual type or structure at runtime.</li>
    <li>Type Casting (in languages like C# or Java) actually converts data at runtime.</li>
  </ul>

  <h5>When to Use</h5>
  <ul>
    <li>When working with DOM elements.</li>
    <li>When migrating JavaScript code to TypeScript.</li>
    <li>When dealing with third-party libraries with incomplete type definitions.</li>
  </ul>

  <p><b>Important:</b> Avoid overusing type assertions ‚Äî they can bypass TypeScript‚Äôs type safety if used incorrectly.</p>
  `,
  16: `
  <h4>Type Casting in TypeScript</h4>
  <p>Type casting is the process of explicitly converting a value from one type to another. In TypeScript, this is done using <b>type assertions</b> ‚Äî but it does not actually change the data at runtime; it only informs the compiler of the intended type.</p>

  <h5>üß© Type Casting Syntax</h5>
  <pre><code>
  // Using 'as' keyword (recommended)
  let value: unknown = "Hello World";
  let length: number = (value as string).length;

  // Using angle bracket syntax (older form)
  let length2: number = (&lt;string&gt;value).length;
  </code></pre>

  <p><b>Note:</b> The <code>&lt;&gt;</code> syntax cannot be used in .tsx (React TypeScript) files because it conflicts with JSX tags.</p>

  <h5>‚úÖ Example ‚Äì Casting from unknown</h5>
  <pre><code>
  function getData(): unknown {
    return "TypeScript Casting";
  }

  let data = getData();
  console.log((data as string).toUpperCase());
  </code></pre>

  <p>Here, <code>getData()</code> returns <code>unknown</code>. Using type casting tells TypeScript we are sure it‚Äôs a string.</p>

  <h5>‚öôÔ∏è Casting Between Types</h5>
  <p>You can cast between compatible types using intermediate <code>unknown</code> or <code>any</code>:</p>
  <pre><code>
  type Cat = { meow: () => void };
  type Dog = { bark: () => void };

  let pet = { bark: () => console.log("Woof!") } as Dog;

  // Unsafe cast (not recommended)
  let cat = pet as unknown as Cat;
  cat.meow(); // Runtime error!
  </code></pre>

  <h5>üí° Type Casting vs Type Assertion</h5>
  <ul>
    <li><b>Type Casting:</b> Converts a variable from one type to another (conceptually).</li>
    <li><b>Type Assertion:</b> Tells the compiler to treat a variable as a specific type.</li>
    <li>In TypeScript, both are effectively the same ‚Äî actual runtime conversion does not occur.</li>
  </ul>

  <h5>üö´ Caution</h5>
  <ul>
    <li>Type casting can bypass TypeScript‚Äôs type safety.</li>
    <li>Always ensure you‚Äôre casting between compatible types.</li>
  </ul>

  <p><b>Summary:</b> Type casting in TypeScript is a compile-time feature that helps the compiler understand the intended type but does not alter runtime behavior.</p>
  `,
  17: `
  <h4>Modules in TypeScript</h4>
  <p>Modules in TypeScript help organize code into separate files and reusable units. Each file in TypeScript can be treated as a module if it contains <code>export</code> or <code>import</code> statements.</p>

  <h5>üåê Why Use Modules?</h5>
  <ul>
    <li>To split large applications into manageable files.</li>
    <li>To promote code reusability and maintainability.</li>
    <li>To avoid global scope pollution.</li>
  </ul>

  <hr/>
  <h4>Exporting from a Module</h4>
  <p>Use <code>export</code> to make variables, functions, classes, or interfaces accessible outside the current file.</p>
  <pre><code>
// mathUtils.ts
export const add = (a: number, b: number): number => a + b;
export const subtract = (a: number, b: number): number => a - b;

export class Calculator {
  multiply(a: number, b: number): number {
    return a * b;
  }
}
  </code></pre>

  <h4>Importing in Another File</h4>
  <p>Use <code>import</code> to bring in exported members.</p>
  <pre><code>
// app.ts
import { add, Calculator } from "./mathUtils";

console.log(add(5, 10)); // 15
const calc = new Calculator();
console.log(calc.multiply(3, 4)); // 12
  </code></pre>

  <h4>Default Exports</h4>
  <p>A module can have one default export. It can be imported with any name.</p>
  <pre><code>
// greet.ts
export default function greet(name: string) {
  return "Hello, " + name + "!";
}

// main.ts
import greet from "./greet";
console.log(greet("Abhi"));
  </code></pre>

  <h4>Renaming Imports and Exports</h4>
  <pre><code>
// export with alias
export { add as addition } from "./mathUtils";

// import with alias
import { addition as sum } from "./mathUtils";
  </code></pre>

  <h4>Re-exporting Modules</h4>
  <pre><code>
// operations.ts
export * from "./mathUtils";
export * from "./stringUtils";
  </code></pre>

  <h4>Module Resolution</h4>
  <p>TypeScript uses module resolution strategies to find imported modules:</p>
  <ul>
    <li><b>Classic:</b> Used for older projects.</li>
    <li><b>Node:</b> Used for Node.js-style imports (recommended).</li>
  </ul>

  <p>You can specify the module type in <code>tsconfig.json</code>:</p>
  <pre><code>
  {
    "compilerOptions": {
      "module": "ESNext", // or "CommonJS", "AMD", "UMD"
      "target": "ES6"
    }
  }
  </code></pre>

  <h4>Namespace vs Module</h4>
  <ul>
    <li><b>Namespaces</b> are for organizing code within a single file or script.</li>
    <li><b>Modules</b> are for organizing code across multiple files using imports/exports.</li>
  </ul>

  <h4>Summary</h4>
  <ul>
    <li>Each file with <code>export</code> or <code>import</code> becomes a module.</li>
    <li>Modules improve reusability, maintainability, and clarity.</li>
    <li>Use <code>import/export</code> for modular, scalable TypeScript applications.</li>
  </ul>
  `,
  18: `
  <h4>Type Declarations in TypeScript (.d.ts Files)</h4>
  <p><strong>Type Declarations</strong> in TypeScript describe the shape and types of existing code ‚Äî especially JavaScript code. They allow the TypeScript compiler to understand what types exist even if there is no implementation provided.</p>
  <p>Type declarations are typically written inside files ending with the extension <code>.d.ts</code> (declaration files).</p>

  <hr/>
  <h4>üí° What Are Declaration Files?</h4>
  <p>A declaration file (<code>.d.ts</code>) tells TypeScript the types of variables, functions, classes, and modules that exist in JavaScript code.</p>
  <p>They contain <strong>only type information</strong>, no executable code.</p>

  <pre><code>// math.d.ts
declare function add(a: number, b: number): number;
declare const PI: number;
  </code></pre>

  <pre><code>// main.ts
console.log(add(2, 3));  // OK
console.log(PI);         // OK
  </code></pre>

  <hr/>
  <h4>üìò Purpose of Type Declarations</h4>
  <ul>
    <li>To provide type information for plain JavaScript libraries or code.</li>
    <li>To enable autocompletion, IntelliSense, and compile-time type checking.</li>
    <li>To make external JS libraries type-safe when used in TS projects.</li>
  </ul>

  <hr/>
  <h4>üß© Declaring Modules</h4>
  <p>When using a JavaScript module that doesn‚Äôt have built-in types, you can declare it manually using the <code>declare module</code> syntax.</p>

  <pre><code>// custom-lib.d.ts
declare module "custom-lib" {
  export function greet(name: string): void;
  export const version: string;
}
  </code></pre>

  <pre><code>// app.ts
import { greet, version } from "custom-lib";
greet("Abhi");
console.log(version);
  </code></pre>

  <hr/>
  <h4>üåê Declaring Global Variables</h4>
  <p>You can declare global variables available throughout your environment.</p>

  <pre><code>// globals.d.ts
declare const APP_NAME: string;
declare function log(message: string): void;
  </code></pre>

  <pre><code>// main.ts
log(\`Welcome to \${APP_NAME}\`);
  </code></pre>

  <hr/>
  <h4>üì¶ Using @types Packages</h4>
  <p>Most popular libraries (React, Node, etc.) already have pre-written declaration files published under the <strong>DefinitelyTyped</strong> repository.</p>
  <p>You can install them via npm:</p>

  <pre><code>npm install --save-dev @types/react
npm install --save-dev @types/node</code></pre>

  <p>This automatically adds their <code>.d.ts</code> files from <code>node_modules/@types</code>.</p>

  <hr/>
  <h4>üõ†Ô∏è Custom Type Declarations</h4>
  <p>If you‚Äôre writing JavaScript but want to use TypeScript later, you can create your own type declarations.</p>

  <pre><code>// types/utils.d.ts
declare function multiply(a: number, b: number): number;
  </code></pre>

  <p>Then configure <code>tsconfig.json</code> to include the custom type root:</p>

  <pre><code>"typeRoots": ["./types", "./node_modules/@types"]</code></pre>

  <hr/>
  <h4>üîë Summary</h4>
  <ul>
    <li><code>.d.ts</code> files define types but contain no code.</li>
    <li>They describe existing JavaScript modules, functions, and variables.</li>
    <li>Enable TypeScript to understand non-TypeScript libraries.</li>
    <li>Used by the TypeScript compiler and IDEs for type safety and autocompletion.</li>
  </ul>

  <p>‚û°Ô∏è In short: <strong>Type Declarations (.d.ts)</strong> make JavaScript type-safe without rewriting it in TypeScript.</p>
  `,
  19: `
  <h4>Creating an NPM Package using TypeScript</h4>
  <p>TypeScript makes it easy to build and publish reusable <strong>NPM packages</strong> with built-in type definitions. This allows other developers to use your library in both JavaScript and TypeScript projects with proper IntelliSense and type safety.</p>

  <hr/>
  <h4>1Ô∏è‚É£ Initialize the Project</h4>
  <p>Create a new folder for your package and initialize it with npm:</p>

  <pre><code>mkdir my-utils
cd my-utils
npm init -y</code></pre>

  <p>This creates a <code>package.json</code> file that defines your package metadata.</p>

  <hr/>
  <h4>2Ô∏è‚É£ Install TypeScript and Setup Compiler</h4>
  <pre><code>npm install typescript --save-dev
npx tsc --init --rootDir src --outDir dist --declaration true --esModuleInterop true</code></pre>

  <p>Key options explained:</p>
  <ul>
    <li><b>rootDir:</b> Source files directory (e.g. <code>src</code>).</li>
    <li><b>outDir:</b> Compiled JavaScript output directory (e.g. <code>dist</code>).</li>
    <li><b>declaration:</b> Generates <code>.d.ts</code> files automatically for TypeScript consumers.</li>
    <li><b>esModuleInterop:</b> Ensures compatibility with CommonJS and ES modules.</li>
  </ul>

  <hr/>
  <h4>3Ô∏è‚É£ Write Your TypeScript Code</h4>
  <pre><code>// src/index.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function greet(name: string): string {
  return \`Hello, \${name}!\`;
}
  </code></pre>

  <p>When compiled, this will generate both <code>index.js</code> and <code>index.d.ts</code> inside the <code>dist</code> folder.</p>

  <hr/>
  <h4>4Ô∏è‚É£ Compile Your Code</h4>
  <pre><code>npx tsc</code></pre>
  <p>This generates the <code>dist</code> folder with compiled files.</p>

  <hr/>
  <h4>5Ô∏è‚É£ Update <code>package.json</code></h4>
  <p>Edit your <code>package.json</code> to point to the correct entry files:</p>

  <pre><code>{
  "name": "my-utils",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc"
  }
}</code></pre>

  <hr/>
  <h4>6Ô∏è‚É£ Test Locally Before Publishing</h4>
  <p>You can test your package locally using <code>npm link</code>:</p>
  <pre><code>npm link</code></pre>
  <p>Then in another project:</p>
  <pre><code>npm link my-utils</code></pre>
  <p>Now you can import your functions like this:</p>
  <pre><code>import { add, greet } from "my-utils";
console.log(add(2, 3));
console.log(greet("Abhi"));</code></pre>

  <hr/>
  <h4>7Ô∏è‚É£ Publishing to NPM</h4>
  <p>Once everything works correctly, publish your package:</p>

  <pre><code>npm login
npm publish --access public</code></pre>

  <p>Your package is now available to everyone via:</p>
  <pre><code>npm install my-utils</code></pre>

  <hr/>
  <h4>8Ô∏è‚É£ Folder Structure Example</h4>
  <pre><code>my-utils/
  ‚îú‚îÄ src/
  ‚îÇ   ‚îî‚îÄ index.ts
  ‚îú‚îÄ dist/
  ‚îÇ   ‚îú‚îÄ index.js
  ‚îÇ   ‚îî‚îÄ index.d.ts
  ‚îú‚îÄ package.json
  ‚îú‚îÄ tsconfig.json
  ‚îî‚îÄ README.md</code></pre>

  <hr/>
  <h4>üîë Summary</h4>
  <ul>
    <li>Initialize an npm project with <code>npm init</code>.</li>
    <li>Use TypeScript for development and enable <code>declaration</code> output.</li>
    <li>Generate <code>.d.ts</code> files automatically for type safety.</li>
    <li>Set correct <code>main</code> and <code>types</code> fields in <code>package.json</code>.</li>
    <li>Use <code>npm publish</code> to share your library with others.</li>
  </ul>

  <p>‚û°Ô∏è With TypeScript, your npm package provides both <b>runtime functionality</b> and <b>type definitions</b> for seamless integration.</p>
  `,
  20: `
  <h4>Async / Await in TypeScript</h4>
  <p><b>Async/Await</b> provides a cleaner way to handle asynchronous operations in TypeScript compared to callbacks or promises.</p>

  <h5>1Ô∏è‚É£ What is <code>async</code>?</h5>
  <p>The <code>async</code> keyword is used before a function to make it return a <b>Promise</b>. Inside an async function, you can use the <code>await</code> keyword to pause execution until the promise resolves.</p>

  <pre><code>
  async function greet(): Promise&lt;string&gt; {
    return "Hello, TypeScript!";
  }

  greet().then(msg =&gt; console.log(msg));
  </code></pre>

  <h5>2Ô∏è‚É£ What is <code>await</code>?</h5>
  <p>The <code>await</code> keyword can only be used inside an <code>async</code> function. It pauses the function execution until the awaited promise is resolved.</p>

  <pre><code>
  async function fetchData() {
    console.log("Fetching data...");
    const data = await new Promise((resolve) =&gt; {
      setTimeout(() =&gt; resolve("Data loaded!"), 2000);
    });
    console.log(data);
  }

  fetchData();
  </code></pre>

  <p>Output:</p>
  <pre><code>
  Fetching data...
  (after 2 seconds)
  Data loaded!
  </code></pre>

  <h5>3Ô∏è‚É£ Error Handling with <code>try...catch</code></h5>
  <p>Async/Await supports synchronous-looking error handling using <code>try...catch</code>.</p>

  <pre><code>
  async function getUser() {
    try {
      const response = await fetch("https://jsonplaceholder.typicode.com/users/1");
      const user = await response.json();
      console.log(user.name);
    } catch (error) {
      console.error("Error fetching user:", error);
    }
  }

  getUser();
  </code></pre>

  <h5>4Ô∏è‚É£ Async Functions Always Return Promises</h5>
  <pre><code>
  async function add(a: number, b: number): Promise&lt;number&gt; {
    return a + b;
  }

  add(5, 10).then(result =&gt; console.log(result)); // Output: 15
  </code></pre>

  <h5>5Ô∏è‚É£ Combining Async / Await with Generics</h5>
  <pre><code>
  async function fetchJson&lt;T&gt;(url: string): Promise&lt;T&gt; {
    const response = await fetch(url);
    return await response.json();
  }

  interface Todo {
    id: number;
    title: string;
    completed: boolean;
  }

  fetchJson&lt;Todo&gt;("https://jsonplaceholder.typicode.com/todos/1")
    .then(todo =&gt; console.log(todo.title));
  </code></pre>

  <h5>‚úÖ Summary</h5>
  <ul>
    <li><code>async</code> functions return a promise.</li>
    <li><code>await</code> pauses execution until a promise resolves.</li>
    <li>Use <code>try...catch</code> for handling async errors.</li>
    <li>Improves readability and maintainability compared to callbacks or .then().</li>
  </ul>
  `,
  21: `
  <h4>ts-node in TypeScript</h4>
  <p><b>ts-node</b> is a TypeScript execution engine for Node.js. It allows you to run TypeScript code directly without manually compiling it using <code>tsc</code>.</p>

  <h5>1Ô∏è‚É£ What is ts-node?</h5>
  <p><code>ts-node</code> is a development tool that executes TypeScript files on the fly by automatically compiling them in memory before running. It‚Äôs useful for quick testing, scripts, and backend development.</p>

  <pre><code>
  // Normally you would compile TypeScript like this:
  tsc index.ts
  node index.js

  // With ts-node, you can skip compilation:
  npx ts-node index.ts
  </code></pre>

  <h5>2Ô∏è‚É£ Installing ts-node</h5>
  <p>To use <code>ts-node</code>, install it along with TypeScript:</p>

  <pre><code>
  npm install -g ts-node typescript
  </code></pre>

  <p>Or locally inside a project:</p>
  <pre><code>
  npm install --save-dev ts-node typescript
  </code></pre>

  <h5>3Ô∏è‚É£ Running TypeScript Files</h5>
  <p>Once installed, run any <code>.ts</code> file directly:</p>

  <pre><code>
  npx ts-node src/app.ts
  </code></pre>

  <p>It automatically reads configuration from <code>tsconfig.json</code> and compiles your code in memory.</p>

  <h5>4Ô∏è‚É£ Example</h5>
  <pre><code>
// app.ts
const greet = (name: string): string => {
  return \`Hello, \${name}!\`;
};

console.log(greet("TypeScript"));
  </code></pre>

  <p>Run it using:</p>
  <pre><code>npx ts-node app.ts</code></pre>

  <p>Output:</p>
  <pre><code>Hello, TypeScript!</code></pre>

  <h5>5Ô∏è‚É£ Using ts-node with Node flags</h5>
  <p>You can pass Node.js options like <code>--watch</code> to enable live reload:</p>

  <pre><code>
  npx ts-node --watch src/index.ts
  </code></pre>

  <h5>6Ô∏è‚É£ Benefits of ts-node</h5>
  <ul>
    <li>No need for manual compilation steps.</li>
    <li>Faster feedback during development.</li>
    <li>Supports modern TypeScript features out of the box.</li>
    <li>Ideal for scripts, CLI tools, and backend APIs.</li>
  </ul>

  <h5>7Ô∏è‚É£ Performance Note</h5>
  <p>For production, it‚Äôs recommended to precompile TypeScript with <code>tsc</code> instead of using <code>ts-node</code> for better performance.</p>

  <h5>‚úÖ Summary</h5>
  <ul>
    <li><code>ts-node</code> lets you run TypeScript directly in Node.js.</li>
    <li>Useful for rapid prototyping and development.</li>
    <li>Not recommended for production deployment.</li>
  </ul>
  `,
  22: `
  <h4>Lexical <code>this</code> in TypeScript</h4>
  <p>In JavaScript and TypeScript, the value of <code>this</code> depends on how a function is called. However, arrow functions behave differently ‚Äî they have a <b>lexical this</b>, meaning they inherit <code>this</code> from their surrounding context.</p>

  <h5>1Ô∏è‚É£ What is "Lexical this"?</h5>
  <p>Lexical <code>this</code> means that arrow functions do not create their own <code>this</code> binding. Instead, they use the <code>this</code> value from the scope in which they were defined.</p>

  <p>In contrast, regular functions have their own <code>this</code> based on how they are invoked (e.g., as a method, constructor, or standalone function).</p>

  <h5>2Ô∏è‚É£ Example without Lexical this</h5>
  <pre><code>
  class Person {
    name: string;
    constructor(name: string) {
      this.name = name;
    }

    greet() {
      setTimeout(function () {
        console.log("Hello, " + this.name); // ‚ùå 'this' is undefined
      }, 1000);
    }
  }

  const p = new Person("Alice");
  p.greet(); // Output: Hello, undefined
  </code></pre>

  <p>Here, the regular function inside <code>setTimeout</code> has its own <code>this</code> (not the class instance), so <code>this.name</code> becomes <code>undefined</code>.</p>

  <h5>3Ô∏è‚É£ Example with Lexical this (using Arrow Function)</h5>
  <pre><code>
  class Person {
    name: string;
    constructor(name: string) {
      this.name = name;
    }

    greet() {
      setTimeout(() => {
        console.log("Hello, " + this.name); // ‚úÖ 'this' refers to Person instance
      }, 1000);
    }
  }

  const p = new Person("Alice");
  p.greet(); // Output: Hello, Alice
  </code></pre>

  <p>Here, the arrow function captures the <code>this</code> value from the class context (lexical scope), so it correctly refers to the instance.</p>

  <h5>4Ô∏è‚É£ Key Takeaways</h5>
  <ul>
    <li><b>Regular functions</b> define their own <code>this</code> depending on how they‚Äôre called.</li>
    <li><b>Arrow functions</b> inherit <code>this</code> from the enclosing lexical scope.</li>
    <li>Lexical <code>this</code> helps avoid common issues when using callbacks or asynchronous code in classes.</li>
  </ul>

  <h5>5Ô∏è‚É£ Practical Tip</h5>
  <p>Prefer arrow functions for event handlers, callbacks, or methods passed to async functions ‚Äî they automatically use the correct <code>this</code> binding.</p>

  <h5>‚úÖ Summary</h5>
  <ul>
    <li>Arrow functions capture <code>this</code> from where they are defined ‚Äî not how they are called.</li>
    <li>Helps avoid losing <code>this</code> in asynchronous code or nested functions.</li>
    <li>Recommended in modern TypeScript for clean, predictable behavior.</li>
  </ul>
  `,
  23: `
    <h4>Readonly Modifier</h4>
    <p>The <code>readonly</code> modifier in TypeScript is used to make object properties immutable after initialization. Once assigned, their values cannot be changed.</p>

    <h5>Example</h5>
    <pre><code>
    class Person {
      readonly id: number;
      name: string;

      constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
      }
    }

    const p = new Person(1, "Alice");
    p.name = "Bob";      // ‚úÖ Allowed
    p.id = 10;           // ‚ùå Error: Cannot assign to readonly property
    </code></pre>

    <p><b>Use Case:</b> Creating constant properties such as IDs, configuration values, or tokens.</p>
  `,

  24: `
    <h4>Union Types</h4>
    <p>Union types allow a variable to hold more than one possible type. Use <code>|</code> to combine types.</p>

    <h5>Example</h5>
    <pre><code>
    let value: string | number;

    value = "hello";  // ‚úÖ
    value = 100;      // ‚úÖ
    value = true;     // ‚ùå Error
    </code></pre>

    <p><b>Use Case:</b> When a value can be one of several types, such as API responses, IDs, or user inputs.</p>
  `,

  25: `
    <h4>Literal Types</h4>
    <p>Literal types restrict a variable to specific predefined values.</p>

    <h5>Example</h5>
    <pre><code>
    let direction: "up" | "down" | "left" | "right";

    direction = "up";     // ‚úÖ
    direction = "forward"; // ‚ùå Not allowed
    </code></pre>

    <p><b>Use Case:</b> Creating constants, configuration flags, or action types.</p>
  `,

  26: `
    <h4>Type Narrowing</h4>
    <p>Type narrowing means reducing a union type to a more specific type using checks like <code>typeof</code>, <code>in</code>, <code>instanceof</code>, or custom checks.</p>

    <h5>Example</h5>
    <pre><code>
    function printLength(x: string | string[]) {
      if (typeof x === "string") {
        console.log(x.length);     // String length
      } else {
        console.log(x.length);     // Array length
      }
    }
    </code></pre>

    <p><b>Use Case:</b> When a variable may hold different types and the code must respond accordingly.</p>
  `,

  27: `
    <h4>Discriminated Unions</h4>
    <p>Discriminated unions are a pattern that combines union types with a common property (called a discriminator) to make type narrowing easier and safer.</p>

    <h5>Example</h5>
    <pre><code>
    type Circle = { kind: "circle", radius: number };
    type Square = { kind: "square", side: number };
    type Shape = Circle | Square;

    function area(shape: Shape) {
      switch (shape.kind) {
        case "circle":
          return Math.PI * shape.radius * shape.radius;
        case "square":
          return shape.side * shape.side;
      }
    }
    </code></pre>

    <p><b>Use Case:</b> Complex data models, state machines, form states, Redux actions.</p>
  `,

  28: `
    <h4>Class Parameter Properties</h4>
    <p>Parameter properties let you declare and initialize class properties directly inside the constructor parameters using <code>public</code>, <code>private</code>, <code>readonly</code>.</p>

    <h5>Example Without Parameter Properties</h5>
    <pre><code>
    class Person {
      name: string;
      age: number;

      constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
      }
    }
    </code></pre>

    <h5>Example With Parameter Properties</h5>
    <pre><code>
    class Person {
      constructor(
        public name: string,
        private age: number,
        readonly id: number
      ) {}
    }

    const p = new Person("Alice", 25, 101);
    </code></pre>

    <p><b>Benefits:</b> Less boilerplate, cleaner constructors, automatic property creation.</p>
  `,

  29: `
    <h4>Strict Compiler Option</h4>

    <p>The <code>"strict"</code> compiler option in <code>tsconfig.json</code> enables TypeScript‚Äôs highest level of type safety. 
    When turned on, it activates a collection of strict type-checking rules that help catch hidden bugs, prevent unsafe operations, and improve code reliability.</p>

    <p>Strict mode is considered the <b>recommended default</b> for all professional TypeScript applications because it prevents silent type errors that could otherwise become runtime failures.</p>

    <pre><code>
{
  "compilerOptions": {
    "strict": true
  }
}
    </code></pre>

    <hr/>

    <h4>What Strict Mode Enables</h4>
    <p>Turning on <code>strict</code> internally enables several individual compiler options. 
    Below is a detailed breakdown of each rule with explanations and examples.</p>

    <h5>1Ô∏è‚É£ strictNullChecks</h5>
    <p>Treats <code>null</code> and <code>undefined</code> as separate types. You must explicitly allow them.</p>

    <pre><code>
let name: string = null;       // ‚ùå Error
let id: number | null = null;  // ‚úÖ Valid
    </code></pre>

    <p>This prevents accidental null-reference bugs.</p>

    <h5>2Ô∏è‚É£ noImplicitAny</h5>
    <p>Disallows variables or parameters that default to <code>any</code>.</p>

    <pre><code>
function sum(a, b) {   // ‚ùå 'a' and 'b' implicitly have type 'any'
  return a + b;
}
    </code></pre>

    <pre><code>
function sum(a: number, b: number) { // ‚úÖ explicit types
  return a + b;
}
    </code></pre>

    <h5>3Ô∏è‚É£ strictBindCallApply</h5>
    <p>Ensures that <code>bind</code>, <code>call</code>, and <code>apply</code> receive the correct parameter types.</p>

    <pre><code>
function greet(name: string) { return "Hello " + name; }

greet.call(null, 123); // ‚ùå Error: expected string, got number
    </code></pre>

    <h5>4Ô∏è‚É£ strictFunctionTypes</h5>
    <p>Ensures that functions assigned to each other follow safe rules for parameter types (contravariance).</p>

    <pre><code>
let fn1 = (a: number) => {};
let fn2 = (a: number | string) => {};

fn1 = fn2; // ‚ùå Not safe
fn2 = fn1; // ‚úÖ Allowed
    </code></pre>

    <h5>5Ô∏è‚É£ noImplicitThis</h5>
    <p>Ensures <code>this</code> is not implicitly typed as <code>any</code>.</p>

    <pre><code>
function click() {
  console.log(this); // ‚ùå this is implicitly 'any'
}
    </code></pre>

    <pre><code>
function click(this: HTMLButtonElement) {
  console.log(this.id); // ‚úÖ correct type
}
    </code></pre>

    <h5>6Ô∏è‚É£ strictPropertyInitialization</h5>
    <p>Ensures class properties are initialized before use.</p>

    <pre><code>
class User {
  name: string; // ‚ùå Error: Property not initialized
}
    </code></pre>

    <pre><code>
class User {
  name: string = "Anonymous"; // ‚úÖ initialized
}
    </code></pre>

    <h5>7Ô∏è‚É£ alwaysStrict</h5>
    <p>Emits JavaScript with <code>"use strict"</code> at the top of files, enforcing safe runtime behavior.</p>

    <hr/>

    <h4>Full Example Comparing Strict vs Non-Strict</h4>

    <h5>üî∏ Without strict mode (unsafe)</h5>
    <pre><code>
function getLength(value) {
  return value.length; // No error, but may crash at runtime
}

console.log(getLength(123)); // ‚ùå Runtime error
    </code></pre>

    <h5>üî∏ With strict mode (safe)</h5>
    <pre><code>
function getLength(value: string) {
  return value.length;
}

getLength(123);  // ‚ùå Compile time error ‚Äî prevented early
    </code></pre>

    <hr/>

    <h4>Why You Should Always Use Strict Mode</h4>
    <ul>
      <li>Prevents hard-to-debug runtime crashes</li>
      <li>Forces explicit, predictable typing</li>
      <li>Makes refactoring safer</li>
      <li>Improves IDE auto-completion and inference</li>
      <li>Encourages intentional handling of <code>null</code> and <code>undefined</code></li>
      <li>Ensures high-quality, maintainable production code</li>
    </ul>

    <p>Strict mode is the foundation for writing reliable and scalable TypeScript applications. 
    It forces you to think clearly about types and eliminates hidden unsafe patterns.</p>
  `,
  30:
  `<h4>Null versus Undefined</h4>

<p>
In TypeScript, <code>null</code> and <code>undefined</code> are two separate primitive types, each representing the absence of a value but in different ways.
Understanding their differences is important for writing safer and more predictable TypeScript code‚Äîespecially when strict type-checking is enabled.
</p>

<p>
By default (without <code>strictNullChecks</code>), both <code>null</code> and <code>undefined</code> are treated as valid values for all types.
But when <code>strictNullChecks</code> is turned ON, TypeScript requires you to explicitly handle them, making your code cleaner and less error-prone.
</p>

<h5>‚úî Meaning and Usage</h5>

<ul>
  <li>
    <b><code>undefined</code></b> ‚Äì A variable has been declared but not assigned any value.
    It represents a value that is missing unintentionally.
  </li>
  <li>
    <b><code>null</code></b> ‚Äì A value intentionally set to represent ‚Äúno value‚Äù or ‚Äúempty state.‚Äù
  </li>
</ul>

<h5>‚úî Key Differences</h5>

<table border="1" cellpadding="6">
  <tr>
    <th>Aspect</th>
    <th>undefined</th>
    <th>null</th>
  </tr>
  <tr>
    <td>Meaning</td>
    <td>Value not assigned</td>
    <td>Explicit empty value</td>
  </tr>
  <tr>
    <td>Assigned By</td>
    <td>JavaScript/TypeScript</td>
    <td>Developer</td>
  </tr>
  <tr>
    <td>Type</td>
    <td><code>undefined</code></td>
    <td><code>object</code></td>
  </tr>
  <tr>
    <td>Common Usage</td>
    <td>Uninitialized variables, missing optional params</td>
    <td>Represent empty data intentionally</td>
  </tr>
</table>

<h5>‚úî Examples</h5>

<p><b>1. undefined example</b></p>
<pre>
let x: number | undefined;
console.log(x); // undefined
</pre>

<p><b>2. null example</b></p>
<pre>
let y: string | null = null;
console.log(y); // null
</pre>

<p><b>3. Function returning null when no result found</b></p>
<pre>
function findUser(id: number): string | null {
  if (id === 1) return "User Found";
  return null;
}
</pre>

<p><b>4. Optional parameters default to undefined</b></p>
<pre>
function greet(message?: string) {
  console.log(message); // undefined if no argument is passed
}
</pre>

<h5>‚úî strictNullChecks Impact</h5>

<p>
When <code>"strictNullChecks": true</code> is enabled, variables cannot contain <code>null</code> or <code>undefined</code> unless their types explicitly allow it.
</p>

<pre>
// With strictNullChecks ON:
let age: number;
age = null;       // ‚ùå Error
age = undefined;  // ‚ùå Error

// Valid:
let age2: number | null | undefined;
</pre>

<h5>‚úî Practical Use Cases</h5>
<ul>
  <li>API responses often use <code>null</code> to represent missing fields.</li>
  <li>Optional parameters and uninitialized variables naturally become <code>undefined</code>.</li>
  <li>Helps in writing cleaner conditional checks and safer code.</li>
</ul>

<p><b>Summary:</b>  
<code>undefined</code> = unintentional absence.  
<code>null</code> = intentional absence.  
<code>strictNullChecks</code> enforces clear handling of both.</p>
  `,
  31: `
<h3>31. Intersection Types</h3>

<h4>Intersection Types</h4>

<p>
Intersection types in TypeScript allow you to combine multiple types into one.
The resulting type must include <b>all properties from all the combined types</b>.
It uses the <code>&</code> (AND) operator.
</p>

<p>
Intersection types are helpful when you want an object that has multiple 
capabilities or characteristics ‚Äî similar to mixins or combining traits.
</p>

<h5>‚úî What Are Intersection Types?</h5>

<p>
An intersection type <code>A & B</code> means the value must satisfy both <code>A</code> and <code>B</code>.
</p>

<pre><code>
type A = { name: string };
type B = { age: number };

type Person = A & B;

const p: Person = {
  name: "John",
  age: 30
};
</code></pre>

<h5>‚úî Why Use Intersection Types?</h5>

<ul>
  <li>To merge multiple object types together.</li>
  <li>To enforce that a value must have multiple features/behaviors.</li>
  <li>To simulate mixins or capability-based design.</li>
</ul>

<h5>‚úî Example: Combining Multiple Abilities</h5>

<pre><code>
type CanWalk = { walk: () => void };
type CanRun  = { run: () => void };
type CanSwim = { swim: () => void };

type SuperHuman = CanWalk & CanRun & CanSwim;

const hero: SuperHuman = {
  walk: () => console.log("Walking"),
  run: () => console.log("Running"),
  swim: () => console.log("Swimming")
};
</code></pre>

<h5>‚úî Intersection with Primitive Types</h5>

<p>
Intersecting incompatible primitive types results in <code>never</code>.
</p>

<pre><code>
type X = string;
type Y = number;

type Z = X & Y;  
// Z = never (impossible type)
</code></pre>

<h5>‚úî Intersection with Unions</h5>

<pre><code>
// Intersection narrows union types
type A = { a: number } | { b: number };
type B = { a: number };

type C = A & B;
// C = { a: number }
</code></pre>

<h5>‚úî Function Example</h5>

<pre><code>
type Logger = { log: (msg: string) => void };
type Formatter = { format: (value: string) => string };

type LoggingFormatter = Logger & Formatter;

const tool: LoggingFormatter = {
  log: msg => console.log(msg),
  format: value => value.trim()
};
</code></pre>

<h5>‚úî Practical Use Cases</h5>

<ul>
  <li>Mixins</li>
  <li>Combining multiple interfaces</li>
  <li>Enforcing multi-capability objects</li>
  <li>Extending library types</li>
</ul>

<h5>‚úî Summary</h5>

<ul>
  <li>Intersection types combine multiple types using <code>&</code>.</li>
  <li>Resulting type must include all members of all types.</li>
  <li>Useful for mixins and capability modeling.</li>
  <li>Incompatible intersections collapse into <code>never</code>.</li>
</ul>
`,
  32: `
<h3>32. Optional Modifier ( ? )</h3>

<h4>What is the Optional Modifier?</h4>

<p>
The optional modifier <code>?</code> in TypeScript allows you to mark properties,
parameters, or object fields as optional.  
This means the value **may or may not be present**.
</p>

<p>
It is used with:  
<ul>
  <li>Object properties</li>
  <li>Function parameters</li>
  <li>Interface or type definitions</li>
</ul>
</p>

<h5>‚úî Optional Property Example</h5>

<pre><code>
type User = {
  id: number;
  name: string;
  age?: number;    // age is optional
};

const u1: User = { id: 1, name: "John" };         // valid
const u2: User = { id: 2, name: "Sam", age: 25 }; // valid
</code></pre>

<h5>‚úî Optional Function Parameter</h5>

<p>
Function parameters with <code>?</code> are optional and default to <code>undefined</code> 
if not supplied.
</p>

<pre><code>
function greet(name?: string): void {
  console.log("Hello " + (name ?? "Guest"));
}

greet();        // Hello Guest
greet("Alice"); // Hello Alice
</code></pre>

<h5>‚úî Optional Modifier Internally Means:</h5>

<pre><code>
age?: number

// is same as

age: number | undefined
</code></pre>

<h5>‚úî Using Optional with Interfaces</h5>

<pre><code>
interface Car {
  model: string;
  mileage?: number;
}
</code></pre>

<h5>‚úî Optional Chaining vs Optional Modifier</h5>

<p><code>?</code> in TypeScript is different based on where it's used:</p>

<ul>
  <li><b>Optional modifier</b>: <code>age?: number</code></li>
  <li><b>Optional chaining</b>: <code>user?.address?.city</code></li>
</ul>

<h5>‚úî Optional With Default Values</h5>

<pre><code>
function multiply(a: number, b?: number) {
  return a * (b ?? 1);
}

multiply(5);      // 5
multiply(5, 2);   // 10
</code></pre>

<h5>‚úî Optional in Class Constructor</h5>

<pre><code>
class Person {
  constructor(
    public name: string,
    public age?: number
  ) {}
}

const p1 = new Person("Alex");
const p2 = new Person("Alex", 30);
</code></pre>

<h5>‚úî Summary</h5>

<ul>
  <li><code>?</code> marks a property or parameter as optional.</li>
  <li>Optional means the value can be missing or undefined.</li>
  <li>Optional parameter defaults to <code>undefined</code>.</li>
  <li>Very common in function design, API responses, and flexible object structures.</li>
</ul>
`,
  33: `
<h3>33. Non-null Assertion Operator ( ! )</h3>

<p>
The <code>!</code> operator in TypeScript is called the
<b>Non-Null Assertion Operator</b>.  
It tells the compiler:  
<strong>‚ÄúI am sure this value is NOT null or undefined ‚Äî trust me!‚Äù</strong>
</p>

<p>
This operator is useful when TypeScript cannot guarantee non-null values,  
but <em>you know</em> (based on logic) that the value definitely exists.
</p>

<hr/>

<h4>‚úî Why is it needed?</h4>

<p>
TypeScript has strict null checking.  
If a variable may be <code>null</code> or <code>undefined</code>, TS gives an error:
</p>

<pre><code>
let el = document.getElementById("title");

console.log(el.innerText); 
// ‚ùå Error: Object is possibly 'null'
</code></pre>

<p>
Using <code>!</code>, we tell TypeScript that <code>el</code> is NOT null:
</p>

<pre><code>
let el = document.getElementById("title")!;
console.log(el.innerText); // ‚úî OK
</code></pre>

<hr/>

<h4>‚úî Common Use Cases</h4>

<h5>1. DOM Access</h5>

<pre><code>
const input = document.querySelector("input#email")!;
input.value = "test@example.com";
</code></pre>

<h5>2. Variables Initialized Later</h5>

<pre><code>
let username!: string;  // will be assigned later

function init() {
  username = "John";
}

init();
console.log(username.toUpperCase());
</code></pre>

<h5>3. Optional Fields You Know Are Present</h5>

<pre><code>
type User = { id: number; email?: string };

const u: User = { id: 1, email: "a@b.com" };

console.log(u.email!.toUpperCase());
</code></pre>

<hr/>

<h4>‚úî What Non-null Assertion is NOT</h4>

<p>
It does NOT check anything at runtime.  
It only removes TypeScript's safety checks.
</p>

<p><b>If you're wrong ‚Üí your program will crash!</b></p>

<pre><code>
const person = { name: null as any };

console.log(person.name!.toUpperCase());
// ‚ùå RUNTIME ERROR: Cannot read properties of null
</code></pre>

<hr/>

<h4>‚úî Use With Caution</h4>

<p>
The <code>!</code> operator bypasses TypeScript safety.  
Use it only when you are 100% sure the value is not null.
</p>

<hr/>

<h4>‚úî Safer Alternatives</h4>

<h5>1. Optional Chaining</h5>
<pre><code>
console.log(user.email?.toUpperCase());
</code></pre>

<h5>2. Null Check</h5>
<pre><code>
if (el !== null) {
  console.log(el.innerText);
}
</code></pre>

<h5>3. Type Narrowing</h5>
<pre><code>
function print(text: string | null) {
  if (text) {
    console.log(text.toUpperCase());
  }
}
</code></pre>

<hr/>

<h4>‚úî Summary</h4>

<ul>
  <li><code>!</code> tells TypeScript ‚Äúthis value is never null‚Äù.</li>
  <li>Useful for DOM, late initialization, optional fields.</li>
  <li>Removes compiler safety ‚Äî dangerous if misused.</li>
  <li>Prefer narrowing and optional chaining when possible.</li>
</ul>
`,
  34: `
<h3>34. Interfaces in TypeScript</h3>

<p>
An <b>interface</b> in TypeScript is a way to define the <b>shape of an object</b>.  
It describes the structure (properties, methods, types) that an object must follow.
</p>

<p>
Interfaces help provide strong typing, ensure consistency, and improve code readability.
</p>

<hr/>

<h4>‚úî Basic Interface Example</h4>

<pre><code>
interface User {
  id: number;
  name: string;
}

const u: User = {
  id: 1,
  name: "Alice"
};
</code></pre>

<p>
If any property is missing or incorrect, TypeScript throws an error.
</p>

<hr/>

<h4>‚úî Optional Properties ( ? )</h4>

<p>Use <code>?</code> when a property may or may not exist.</p>

<pre><code>
interface Product {
  id: number;
  name: string;
  description?: string;  // optional
}

const p: Product = { id: 10, name: "Laptop" }; // ‚úî OK
</code></pre>

<hr/>

<h4>‚úî Readonly Properties</h4>

<p>
Prevents changing a value after initialization.
</p>

<pre><code>
interface Config {
  readonly apiKey: string;
}

const cfg: Config = { apiKey: "XYZ123" };
cfg.apiKey = "ABC"; // ‚ùå Error: cannot assign to readonly property
</code></pre>

<hr/>

<h4>‚úî Method Definitions in Interfaces</h4>

<pre><code>
interface Animal {
  name: string;
  speak(): void;
}

class Dog implements Animal {
  name = "Buddy";
  speak() {
    console.log("Woof!");
  }
}
</code></pre>

<p>The class must implement all properties and methods.</p>

<hr/>

<h4>‚úî Interface Extending Another Interface</h4>

<p>Interfaces support inheritance using <code>extends</code>.</p>

<pre><code>
interface Person {
  name: string;
}

interface Employee extends Person {
  salary: number;
}

const e: Employee = {
  name: "Bob",
  salary: 50000
};
</code></pre>

<hr/>

<h4>‚úî Multiple Interface Inheritance</h4>

<pre><code>
interface A { a: string; }
interface B { b: number; }

interface C extends A, B {}

const obj: C = {
  a: "hello",
  b: 42
};
</code></pre>

<hr/>

<h4>‚úî Interfaces for Function Types</h4>

<pre><code>
interface AddFunc {
  (x: number, y: number): number;
}

const add: AddFunc = (a, b) => a + b;
</code></pre>

<hr/>

<h4>‚úî Interfaces for Index Signatures</h4>

<pre><code>
interface StringDictionary {
  [key: string]: string;
}

const dict: StringDictionary = {
  name: "Alice",
  city: "Delhi"
};
</code></pre>

<hr/>

<h4>‚úî Interfaces vs Objects</h4>

<p>Interfaces are only used at <b>compile time</b>.  
They do not exist in JavaScript output.</p>

<p>
They help developers by enforcing structure and type checks.
</p>

<hr/>

<h4>‚úî Summary</h4>

<ul>
  <li>Interfaces define object shapes.</li>
  <li>Support optional & readonly properties.</li>
  <li>Can define objects, functions, classes, arrays, and dictionaries.</li>
  <li>Support inheritance and multiple inheritance.</li>
  <li>Used only for type-checking (not runtime).</li>
</ul>
`,
  35: `
    <h3>35. Interface Declaration Merging</h3>

    <p>
      <b>Interface Declaration Merging</b> is a TypeScript feature where 
      multiple interfaces with the <b>same name</b> automatically combine 
      into a single interface. Only <b>interfaces</b> support merging ‚Äî 
      <code>type</code> aliases <b>do NOT merge</b>.
    </p>

    <hr/>

    <h4>‚úî How Merging Works</h4>
    <p>
      When two or more interfaces share the same name, TypeScript merges all 
      their properties into one final interface.
    </p>

    <pre><code>
interface User {
  id: number;
}

interface User {
  name: string;
}

const u: User = {
  id: 1,
  name: "Abhishek"
};
    </code></pre>

    <p>
      The final interface becomes:
      <code>{ id: number; name: string }</code>
    </p>

    <hr/>

    <h4>‚úî Method Overload Merging</h4>
    <p>If two interfaces define methods with the same name, TypeScript merges them as overloads.</p>

    <pre><code>
interface Api {
  call(endpoint: string): void;
}

interface Api {
  call(endpoint: string, method: string): void;
}
    </code></pre>

    <p>Now, <code>call()</code> supports both overloads.</p>

    <hr/>

    <h4>‚úî Conflicting Types Cause Errors</h4>

    <pre><code>
interface Box {
  size: number;
}

interface Box {
  size: string; // ‚ùå Error: conflicting types
}
    </code></pre>

    <p>Both interfaces must have compatible types to merge successfully.</p>

    <hr/>

    <h4>‚úî Real Use Cases</h4>
    <ul>
      <li>Extending browser <code>Window</code> object</li>
      <li>Adding fields to Express <code>Request</code></li>
      <li>Customizing third-party library types</li>
      <li>Used heavily in <b>.d.ts</b> declaration files</li>
    </ul>

    <hr/>

    <h4>‚úî Example ‚Äì Extending Express Request</h4>

    <pre><code>
declare module "express" {
  interface Request {
    userId?: string;
  }
}
    </code></pre>

    <p>This merges with Express's original <code>Request</code> interface.</p>

    <hr/>

    <h4>‚úî Summary</h4>
    <ul>
      <li>Interfaces with the same name merge automatically</li>
      <li>Useful for extending libraries and global objects</li>
      <li>Method overloads are merged too</li>
      <li>Conflicting types break merging</li>
      <li>Important when writing <b>.d.ts</b> files</li>
    </ul>
  `,
  36: `
    <h3>36. Types versus Interfaces</h3>

    <p>
      In TypeScript, both <b>type aliases</b> and <b>interfaces</b> are used to define the shape of objects, 
      but they have different capabilities and use cases. Understanding the differences helps you choose the right one.
    </p>

    <hr/>

    <h4>‚úî Interfaces</h4>
    <p>Interfaces are mainly used to describe object shapes and class structures.</p>

    <ul>
      <li>Supports <b>declaration merging</b></li>
      <li>Can be <b>implemented</b> by classes</li>
      <li>Can extend interfaces and type aliases</li>
      <li>Best for OOP / structural design</li>
    </ul>

    <pre><code>
interface User {
  id: number;
}

interface User {
  name: string;
}

// Merged:
const u: User = { id: 1, name: "John" };
    </code></pre>

    <hr/>

    <h4>‚úî Type Aliases</h4>
    <p>Type aliases can represent more than just objects.</p>

    <ul>
      <li>Can define unions</li>
      <li>Can define intersections</li>
      <li>Can define primitives and tuples</li>
      <li>Do <b>NOT</b> support declaration merging</li>
    </ul>

    <pre><code>
type Status = "pending" | "done";
type Point = { x: number; y: number };
type Pair = [number, string];
    </code></pre>

    <hr/>

    <h4>‚úî Key Differences</h4>

    <table border="1" cellpadding="6">
      <tr>
        <th>Feature</th>
        <th>Interface</th>
        <th>Type Alias</th>
      </tr>
      <tr>
        <td>Declaration Merging</td>
        <td>‚úî Yes</td>
        <td>‚ùå No</td>
      </tr>
      <tr>
        <td>Describe Objects</td>
        <td>‚úî Yes</td>
        <td>‚úî Yes</td>
      </tr>
      <tr>
        <td>Union / Intersection</td>
        <td>‚ùå No</td>
        <td>‚úî Yes</td>
      </tr>
      <tr>
        <td>Classes can implement?</td>
        <td>‚úî Yes</td>
        <td>‚úî Yes</td>
      </tr>
      <tr>
        <td>Extends</td>
        <td>‚úî Interface / Type</td>
        <td>‚úî Interface / Type</td>
      </tr>
    </table>

    <hr/>

    <h4>‚úî When to Use What?</h4>

    <ul>
      <li>Use <b>interface</b> when designing objects, classes, APIs</li>
      <li>Use <b>type</b> when using unions, primitives, tuples, or complex combinations</li>
    </ul>

    <hr/>

    <h4>‚úî Examples</h4>

    <pre><code>
// Interface for object shape
interface Person {
  id: number;
  name: string;
}

// Type for union or combinations
type Result = Person | null;

// Type for primitives
type StringOrNumber = string | number;

// Interface for class implementation
class Employee implements Person {
  constructor(
    public id: number,
    public name: string
  ) {}
}
    </code></pre>

    <hr/>

    <h4>‚úî Summary</h4>
    <ul>
      <li>Interfaces merge; types don't</li>
      <li>Types support unions and primitives; interfaces don't</li>
      <li>Both can be extended and implemented</li>
      <li>Interfaces are best for object and class structures</li>
      <li>Types are more flexible for advanced type compositions</li>
    </ul>
  `,
  37: `
    <h3>37. never type</h3>

    <p>
      In TypeScript, the <b>never</b> type represents a value that <u>never occurs</u>.  
      It is used for functions that never return or for code paths that are impossible.
    </p>

    <hr/>

    <h4>‚úî When does <code>never</code> occur?</h4>

    <ul>
      <li>Functions that <b>never return</b> (infinite loop)</li>
      <li>Functions that <b>always throw an error</b></li>
      <li><b>Exhaustiveness checking</b> in union types</li>
      <li>Unreachable code paths</li>
    </ul>

    <pre><code>
// 1. Function that never returns
function loopForever(): never {
  while (true) {}
}

// 2. Function that always throws
function fail(message: string): never {
  throw new Error(message);
}
    </code></pre>

    <hr/>

    <h4>‚úî never vs void</h4>

    <table border="1" cellpadding="6">
      <tr>
        <th>void</th>
        <th>never</th>
      </tr>
      <tr>
        <td>Function returns nothing</td>
        <td>Function does NOT return at all</td>
      </tr>
      <tr>
        <td>Function completes normally</td>
        <td>Function doesn't complete</td>
      </tr>
    </table>

    <pre><code>
function log(msg: string): void {
  console.log(msg); // completes normally
}

function crash(): never {
  throw new Error("App crashed"); // never returns
}
    </code></pre>

    <hr/>

    <h4>‚úî never with Exhaustive Checks</h4>
    <p>
      <b>never</b> is useful in switch-case statements to ensure all possible union values are handled.
    </p>

    <pre><code>
type Shape = "circle" | "square" | "triangle";

function handleShape(s: Shape) {
  switch (s) {
    case "circle":
      return "Circle selected";
    case "square":
      return "Square selected";
    case "triangle":
      return "Triangle selected";
    default:
      const unexpected: never = s; // ‚ùå compile error if new type added
      return unexpected;
  }
}
    </code></pre>

    <p>
      This ensures TypeScript warns you if a new union member is added but not handled.
    </p>

    <hr/>

    <h4>‚úî Why is never important?</h4>

    <ul>
      <li>Helps catch impossible code paths</li>
      <li>Makes union handling safer</li>
      <li>Improves compiler strictness</li>
      <li>Useful in ‚Äúexhaustive pattern matching‚Äù</li>
    </ul>

    <hr/>

    <h4>‚úî Summary</h4>
    <ul>
      <li><b>never</b> means ‚Äúthis should never happen.‚Äù</li>
      <li>Used when a function cannot return.</li>
      <li>Excellent for strict safety in switch-case over unions.</li>
      <li>More strict than void.</li>
    </ul>
  `





















    };

    //#endregion  


    const grid = document.getElementById('grid');
    const countEl = document.getElementById('count');
    const search = document.getElementById('search');
    const filter = document.getElementById('filter');
    const reset = document.getElementById('reset');

    function render(list) {
      grid.innerHTML = '';
      list.forEach(t => {
        const card = document.createElement('article');
        card.className = 'card';
        card.innerHTML = `
          <div class="meta">
            <div class="num">#${t.n}</div>
            <div class="cat ${t.cat.toLowerCase()}">${t.cat}</div>
          </div>
          <h4 class="title">${t.title}</h4>
          <p class="desc">Click to read full notes</p>

        `;
        card.onclick = () => openModal(t);
        grid.appendChild(card);
      });
      countEl.textContent = list.length;
    }

    function applyFilters() {
      const q = search.value.trim().toLowerCase();
      const cat = filter.value;
      const out = topics.filter(t => {
        const matchCat = cat === 'all' || t.cat === cat;
        const matchQ = q === '' || t.title.toLowerCase().includes(q) || String(t.n).includes(q);
        return matchCat && matchQ;
      });
      render(out);
    }

    function openModal(topic) {
      document.getElementById('modalTitle').textContent = `#${topic.n} ‚Äî ${topic.title}`;
      document.getElementById('modalBody').innerHTML = topicContent[topic.n] || `<p>Content not available yet.</p>`;
      $('#topicModal').modal('show');
    }

    search.addEventListener('input', applyFilters);
    filter.addEventListener('change', applyFilters);
    reset.addEventListener('click', () => { search.value = ''; filter.value = 'all'; applyFilters(); });

    render(topics);
  </script>
</body>

</html>