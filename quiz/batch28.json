[
  {
    "question": "What happens if you call multiple state setters sequentially in a functional component?",
    "options": [
      "Each setState triggers a separate re-render",
      "React batches updates in event handlers",
      "React ignores the first setState",
      "Updates happen in reverse order"
    ],
    "answer": "React batches updates in event handlers"
  },
  {
    "question": "Why should state updates based on previous state use the functional form?",
    "options": [
      "To avoid stale closures",
      "To ensure proper batching",
      "To prevent race conditions",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "question": "Which hook can help to debounce or throttle a value in React?",
    "options": ["useMemo", "useCallback", "useRef with custom logic", "useEffect"],
    "answer": "useRef with custom logic"
  },
  {
    "question": "What will happen if a child component receives a new function prop on every render?",
    "options": [
      "Child re-renders unnecessarily",
      "Child re-renders only once",
      "Child never re-renders",
      "React throws an error"
    ],
    "answer": "Child re-renders unnecessarily"
  },
  {
    "question": "Which hook is best for storing mutable values that don’t cause re-renders?",
    "options": ["useRef", "useState", "useEffect", "useMemo"],
    "answer": "useRef"
  },
  {
    "question": "What will happen if you pass an object as a dependency to useEffect that is recreated on every render?",
    "options": [
      "Effect will run every render",
      "Effect runs once",
      "Effect is skipped",
      "React throws an error"
    ],
    "answer": "Effect will run every render"
  },
  {
    "question": "Which React concept helps avoid re-rendering child components unnecessarily?",
    "options": [
      "React.memo",
      "useCallback",
      "useMemo",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "question": "Why is the key prop important in lists?",
    "options": [
      "It helps React identify elements",
      "Improves performance",
      "Prevents incorrect DOM updates",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "question": "What happens when useEffect depends on a changing prop?",
    "options": [
      "Effect re-runs whenever prop changes",
      "Effect never runs",
      "Effect runs only once",
      "Effect runs asynchronously"
    ],
    "answer": "Effect re-runs whenever prop changes"
  },
  {
    "question": "Which hook is ideal for performing side effects after rendering?",
    "options": ["useEffect", "useMemo", "useCallback", "useRef"],
    "answer": "useEffect"
  },
  {
    "question": "How can you prevent expensive computations from running on every render?",
    "options": [
      "useMemo",
      "useCallback",
      "React.memo",
      "useRef"
    ],
    "answer": "useMemo"
  },
  {
    "question": "What is the difference between useEffect and useLayoutEffect?",
    "options": [
      "useLayoutEffect runs synchronously before painting, useEffect runs after painting",
      "useEffect runs before rendering, useLayoutEffect after",
      "No difference",
      "useLayoutEffect runs asynchronously"
    ],
    "answer": "useLayoutEffect runs synchronously before painting, useEffect runs after painting"
  },
  {
    "question": "Why might a component re-render even if props haven’t changed?",
    "options": [
      "Parent re-render triggers child render",
      "State updates inside child",
      "Context value changes",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "question": "Which hook allows you to cache function instances across renders?",
    "options": ["useCallback", "useMemo", "useRef", "useEffect"],
    "answer": "useCallback"
  },
  {
    "question": "If a component renders a list of items and uses index as key, what could go wrong?",
    "options": [
      "List items may not update correctly when reordered",
      "React throws an error",
      "Performance improves",
      "No effect"
    ],
    "answer": "List items may not update correctly when reordered"
  },
  {
    "question": "How can you avoid the stale closure problem in hooks?",
    "options": [
      "Include dependencies in useEffect/useCallback",
      "Use refs for mutable values",
      "Use functional updates for state",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "question": "Which of the following will NOT cause a re-render?",
    "options": [
      "Changing a ref value",
      "Updating state",
      "Receiving new props",
      "Context value change"
    ],
    "answer": "Changing a ref value"
  },
  {
    "question": "What happens if you forget to pass a dependency array to useEffect that fetches data?",
    "options": [
      "Effect runs on every render, causing multiple fetches",
      "Effect runs once",
      "Effect never runs",
      "React throws an error"
    ],
    "answer": "Effect runs on every render, causing multiple fetches"
  },
  {
    "question": "Why is using useReducer better than multiple useState for complex state?",
    "options": [
      "Centralizes state logic",
      "Predictable state updates",
      "Simplifies debugging",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "question": "Which approach helps improve performance of a large component tree?",
    "options": [
      "React.memo",
      "Splitting components",
      "useCallback/useMemo",
      "All of the above"
    ],
    "answer": "All of the above"
  }
]
