[
  {
    "question": "What happens if you call setState multiple times in a row with object state in a class component?",
    "options": [
      "All updates are merged and component re-renders once",
      "Each update triggers separate re-render",
      "Only the last update applies",
      "React throws error"
    ],
    "answer": "All updates are merged and component re-renders once"
  },
  {
    "question": "Why is it important to include all dependencies in useEffect?",
    "options": [
      "To avoid stale closure bugs",
      "To ensure effect runs when needed",
      "To prevent unpredictable behavior",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "question": "Which React Hook allows storing mutable values without causing re-renders?",
    "options": ["useRef", "useState", "useMemo", "useReducer"],
    "answer": "useRef"
  },
  {
    "question": "What is the effect of changing a key prop on a component?",
    "options": [
      "Component is recreated and remounted",
      "Component updates normally",
      "Component throws error",
      "No effect"
    ],
    "answer": "Component is recreated and remounted"
  },
  {
    "question": "Which hook allows running code before the browser paints?",
    "options": ["useLayoutEffect", "useEffect", "useMemo", "useCallback"],
    "answer": "useLayoutEffect"
  },
  {
    "question": "What happens if a functional componentâ€™s state is updated with the same value?",
    "options": [
      "Component re-renders anyway",
      "React skips re-render",
      "React throws warning",
      "State resets"
    ],
    "answer": "React skips re-render"
  },
  {
    "question": "Which of these helps prevent unnecessary re-renders of a child component?",
    "options": [
      "React.memo",
      "useCallback for props functions",
      "useMemo for expensive values",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "question": "What problem occurs when you use index as key for dynamic lists?",
    "options": [
      "State may not stay consistent after reordering",
      "Component crashes",
      "React ignores items",
      "No problem"
    ],
    "answer": "State may not stay consistent after reordering"
  },
  {
    "question": "Why is useCallback used in React?",
    "options": [
      "To memoize functions and avoid unnecessary recreations",
      "To memoize values",
      "To replace useMemo",
      "To manage refs"
    ],
    "answer": "To memoize functions and avoid unnecessary recreations"
  },
  {
    "question": "Which of the following will NOT cause a functional component to re-render?",
    "options": [
      "Ref value change",
      "State change",
      "Props change",
      "Context value change"
    ],
    "answer": "Ref value change"
  },
  {
    "question": "What is the main purpose of useMemo?",
    "options": [
      "Cache expensive calculations between renders",
      "Cache functions",
      "Track DOM elements",
      "Force re-render"
    ],
    "answer": "Cache expensive calculations between renders"
  },
  {
    "question": "If a component is wrapped with React.memo, what determines whether it re-renders?",
    "options": [
      "Shallow comparison of props",
      "Deep comparison of props",
      "State changes only",
      "Always re-renders"
    ],
    "answer": "Shallow comparison of props"
  },
  {
    "question": "What is the stale closure problem?",
    "options": [
      "A hook referencing outdated state or props in effect or callback",
      "Memory leak",
      "Broken ref",
      "React warning"
    ],
    "answer": "A hook referencing outdated state or props in effect or callback"
  },
  {
    "question": "Which hook is recommended for handling complex state transitions?",
    "options": ["useReducer", "useState", "useRef", "useEffect"],
    "answer": "useReducer"
  },
  {
    "question": "What happens if you mutate state directly in React?",
    "options": [
      "React may not detect change and skip re-render",
      "Component crashes",
      "React updates normally",
      "State resets"
    ],
    "answer": "React may not detect change and skip re-render"
  },
  {
    "question": "Which hook should you use to perform side effects like fetching data?",
    "options": ["useEffect", "useLayoutEffect", "useMemo", "useCallback"],
    "answer": "useEffect"
  },
  {
    "question": "What happens when you pass an empty dependency array to useEffect?",
    "options": [
      "Effect runs only once after initial render",
      "Effect runs every render",
      "Effect never runs",
      "Effect runs twice"
    ],
    "answer": "Effect runs only once after initial render"
  },
  {
    "question": "Which approach helps optimize performance for large lists?",
    "options": [
      "Virtualization (react-window/react-virtual)",
      "React.memo for list items",
      "Stable key props",
      "All of the above"
    ],
    "answer": "All of the above"
  },
  {
    "question": "What is the correct way to update state based on previous state in a functional component?",
    "options": [
      "setState(prev => prev + 1)",
      "setState(newState)",
      "state = state + 1",
      "Direct mutation"
    ],
    "answer": "setState(prev => prev + 1)"
  },
  {
    "question": "Why is key prop critical for React lists?",
    "options": [
      "Helps React identify elements efficiently",
      "Improves rendering performance",
      "Prevents incorrect DOM updates",
      "All of the above"
    ],
    "answer": "All of the above"
  }
]
